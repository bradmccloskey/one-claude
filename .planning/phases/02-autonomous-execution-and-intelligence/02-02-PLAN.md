---
phase: 02-autonomous-execution-and-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/decision-executor.js
  - lib/commands.js
autonomous: true

must_haves:
  truths:
    - "In cautious mode, AI autonomously starts sessions and sends notifications"
    - "In moderate mode, AI autonomously starts, stops, and restarts sessions"
    - "In full mode, AI executes all actions without confirmation"
    - "In observe mode, no actions are executed (same as Phase 1 behavior)"
    - "Precondition checks prevent starting already-running sessions and stopping non-running sessions"
    - "Cooldown is recorded after each executed action"
    - "User can change autonomy level at runtime via SMS 'ai level <level>'"
    - "Error retry count is tracked per project with a configurable cap"
  artifacts:
    - path: "lib/decision-executor.js"
      provides: "Full action execution with autonomy gating and precondition checks"
      min_lines: 250
      exports: ["DecisionExecutor"]
    - path: "lib/commands.js"
      provides: "AI level set command and updated help"
      contains: "ai level"
  key_links:
    - from: "lib/decision-executor.js"
      to: "lib/session-manager.js"
      via: "execute() calls startSession/stopSession/restartSession"
      pattern: "sessionManager\\.(start|stop|restart)Session"
    - from: "lib/decision-executor.js"
      to: "lib/state.js"
      via: "execute() logs to executionHistory, tracks error retries"
      pattern: "state\\.(logExecution|recordErrorRetry|getErrorRetryCount)"
    - from: "lib/decision-executor.js"
      to: "lib/notification-manager.js"
      via: "execute() notifies via appropriate tiers"
      pattern: "notificationManager\\.notify"
    - from: "lib/commands.js"
      to: "lib/state.js"
      via: "ai level <set> persists to runtimeAutonomyLevel"
      pattern: "setAutonomyLevel"
---

<objective>
Wire the DecisionExecutor to actually execute actions based on autonomy level, with just-in-time precondition checks and safety guardrails.

Purpose: This is THE core Phase 2 deliverable. The executor was a no-op scaffold in Phase 1. Now it becomes a real execution engine that dispatches AI decisions to sessionManager methods with safety gates.

Output: Fully wired decision-executor.js with autonomy gating matrix, precondition checks, error retry tracking, and execution logging. Updated commands.js with `ai level <set>` command.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-RESEARCH.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-01-SUMMARY.md
@lib/decision-executor.js
@lib/commands.js
@lib/session-manager.js
@lib/state.js
@lib/notification-manager.js
@config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DecisionExecutor.execute() with autonomy gating and preconditions</name>
  <files>lib/decision-executor.js</files>
  <action>
Replace the `execute()` scaffold with a real execution engine. The constructor must accept additional deps: `notificationManager`, `signalProtocol`, `state`, and `config` (config is already there).

**Updated constructor signature:**
```javascript
constructor({ sessionManager, messenger, notificationManager, signalProtocol, state, config })
```

Store `this.notificationManager`, `this.signalProtocol`, `this.state` alongside existing deps. Maintain backward compatibility -- if `notificationManager` is null/undefined, fall back to `messenger.send()` directly.

**Update `evaluate()` method:**
Change how `observeOnly` is determined. Instead of reading from `this.config.ai?.autonomyLevel`, read the runtime level:
```javascript
const s = this.state ? this.state.load() : {};
const autonomyLevel = this.state
  ? this.state.getAutonomyLevel(s, this.config)
  : (this.config.ai?.autonomyLevel || 'observe');
result.observeOnly = autonomyLevel === 'observe';
result.autonomyLevel = autonomyLevel;
```

**New `execute()` method -- the core replacement:**

```javascript
async execute(evaluatedRecommendation) {
  const rec = evaluatedRecommendation;

  // 1. Reject if not validated
  if (!rec.validated) {
    return { executed: false, action: rec.action, project: rec.project, rejected: rec.rejected };
  }

  // 2. Check autonomy level gating
  const s = this.state ? this.state.load() : {};
  const autonomyLevel = this.state
    ? this.state.getAutonomyLevel(s, this.config)
    : 'observe';

  if (!this._isActionAllowed(rec.action, autonomyLevel)) {
    // Action not allowed at this autonomy level -- notify instead
    const smsText = `AI would ${rec.action} ${rec.project}: ${rec.reason}`;
    this._notify(smsText, 3);  // tier 3 = summary
    return { executed: false, action: rec.action, project: rec.project, rejected: 'autonomy_level', autonomyLevel };
  }

  // 3. Just-in-time precondition checks
  const precondition = await this._checkPreconditions(rec);
  if (!precondition.ok) {
    return { executed: false, action: rec.action, project: rec.project, rejected: 'precondition_failed', reason: precondition.reason };
  }

  // 4. Execute the action
  let result;
  try {
    switch (rec.action) {
      case 'start':
        // Inject signal protocol before starting
        if (this.signalProtocol) {
          this.signalProtocol.injectClaudeMd(rec.project);
        }
        result = this.sessionManager.startSession(rec.project, rec.prompt);
        break;
      case 'stop':
        result = this.sessionManager.stopSession(rec.project);
        break;
      case 'restart':
        if (this.signalProtocol) {
          this.signalProtocol.injectClaudeMd(rec.project);
        }
        result = this.sessionManager.restartSession(rec.project, rec.prompt);
        break;
      case 'notify':
        const msg = rec.message || rec.reason || 'AI notification';
        this._notify(msg, rec.notificationTier || 2);
        result = { success: true, message: 'Notification sent' };
        break;
      case 'skip':
        result = { success: true, message: `Skipped ${rec.project}: ${rec.reason}` };
        break;
      default:
        result = { success: false, message: `Unknown action: ${rec.action}` };
    }
  } catch (err) {
    result = { success: false, message: `Execution error: ${err.message}` };
  }

  // 5. Post-action bookkeeping
  this._recordAction(rec.project, rec.action);

  // 6. Log execution to state
  if (this.state) {
    const execRecord = {
      timestamp: new Date().toISOString(),
      action: rec.action,
      project: rec.project,
      result: { success: result.success, message: result.message },
      autonomyLevel,
      stateVersion: s.stateVersion || 0,
    };
    this.state.logExecution(s, execRecord);
  }

  // 7. Notify about major actions (start/stop/restart)
  if (result.success && ['start', 'stop', 'restart'].includes(rec.action)) {
    const actionText = `AI ${rec.action}ed ${rec.project}: ${rec.reason}`;
    this._notify(actionText, 2);  // tier 2 = action
  }

  return {
    executed: result.success,
    action: rec.action,
    project: rec.project,
    result,
    timestamp: new Date().toISOString(),
    autonomyLevel,
  };
}
```

**Autonomy gating matrix -- add `_isActionAllowed(action, level)`:**

```javascript
static AUTONOMY_MATRIX = {
  observe:  { start: false, stop: false, restart: false, notify: false, skip: true },
  cautious: { start: true,  stop: false, restart: false, notify: true,  skip: true },
  moderate: { start: true,  stop: true,  restart: true,  notify: true,  skip: true },
  full:     { start: true,  stop: true,  restart: true,  notify: true,  skip: true },
};

_isActionAllowed(action, level) {
  const matrix = DecisionExecutor.AUTONOMY_MATRIX[level];
  if (!matrix) return false;
  return matrix[action] || false;
}
```

**Just-in-time precondition checks -- add `_checkPreconditions(rec)`:**

```javascript
async _checkPreconditions(rec) {
  const { action, project } = rec;

  if (action === 'start') {
    // 1. Check session not already running
    const sessions = this.sessionManager.getActiveSessions();
    const running = sessions.some(s => s.projectName === project);
    if (running) return { ok: false, reason: `Session already running for ${project}` };

    // 2. Check concurrent limit
    if (sessions.length >= this.sessionManager.maxConcurrent) {
      return { ok: false, reason: `Max concurrent sessions (${this.sessionManager.maxConcurrent}) reached` };
    }

    // 3. Check memory
    const os = require('os');
    const minMB = this.config.ai?.resourceLimits?.minFreeMemoryMB || 2048;
    const freeMB = Math.round(os.freemem() / 1024 / 1024);
    if (freeMB < minMB) {
      return { ok: false, reason: `Low memory: ${freeMB}MB free, need ${minMB}MB` };
    }

    // 4. Check error retry cap
    if (this.state) {
      const s = this.state.load();
      const retries = this.state.getErrorRetryCount(s, project);
      const maxRetries = this.config.ai?.maxErrorRetries || 3;
      if (retries >= maxRetries) {
        return { ok: false, reason: `Error retry cap reached (${retries}/${maxRetries}) for ${project}` };
      }
    }
  }

  if (action === 'stop' || action === 'restart') {
    // Check session IS running
    const sessions = this.sessionManager.getActiveSessions();
    const running = sessions.some(s => s.projectName === project);
    if (!running) return { ok: false, reason: `No running session for ${project}` };
  }

  return { ok: true };
}
```

**Helper -- add `_notify(text, tier)`:**

```javascript
_notify(text, tier = 2) {
  if (this.notificationManager) {
    this.notificationManager.notify(text, tier);
  } else if (this.messenger) {
    this.messenger.send(text);
  }
}
```

**Update `formatForSMS()` to show autonomy level correctly:**
Replace the hardcoded `autonomyLevel === "observe"` check with:
```javascript
const s = this.state ? this.state.load() : {};
const autonomyLevel = this.state
  ? this.state.getAutonomyLevel(s, this.config)
  : (this.config.ai?.autonomyLevel || 'observe');
```

Add `os` require at top of file: `const os = require('os');`
  </action>
  <verify>
- `node -e "const DE = require('./lib/decision-executor'); console.log(typeof DE.AUTONOMY_MATRIX)"` prints `object`
- `node -e "const DE = require('./lib/decision-executor'); const d = new DE({sessionManager:{},messenger:{},config:{ai:{}}}); console.log(typeof d.execute)"` prints `function`
- Verify the autonomy matrix has correct entries for all 4 levels and 5 actions
- All existing modules still load: `node -e "require('./lib/commands'); require('./lib/ai-brain'); console.log('OK')"`
  </verify>
  <done>
- execute() dispatches to sessionManager.startSession/stopSession/restartSession based on action
- Autonomy gating matrix correctly gates actions per level (observe=none, cautious=start+notify, moderate=start+stop+restart+notify, full=all)
- Just-in-time precondition checks prevent: starting already-running sessions, exceeding concurrent limit, low memory, error retry cap
- Signal protocol injected before start/restart actions
- Cooldown recorded after each executed action
- Execution logged to state.executionHistory
- Notifications sent via notificationManager with appropriate tiers
- Backward compatible when notificationManager/signalProtocol/state are null
  </done>
</task>

<task type="auto">
  <name>Task 2: Add `ai level <set>` SMS command with runtime persistence</name>
  <files>lib/commands.js</files>
  <action>
Update the `_handleAiLevel()` method in CommandRouter to support SETTING the autonomy level, not just reading it. Also add `state` to the constructor dependencies.

**Constructor update:**
Add `this.state = deps.state;` (it's already passed in from index.js).

Wait -- check. Looking at the current constructor: `this.state = deps.state;` -- it IS already there. Good.

**Update `_handleAiLevel()`:**
Currently shows a static "observe" message. Replace with:

```javascript
_handleAiLevel(args) {
  if (!this.aiBrain) return 'AI brain not configured.';

  // If no args, show current level
  if (!args) {
    const s = this.state.load();
    const level = this.state.getAutonomyLevel(s, this.aiBrain.config);
    return [
      `Autonomy: ${level}`,
      '',
      'Levels:',
      '  observe  - SMS recommendations only (no actions)',
      '  cautious - AI starts sessions, notifies for stops',
      '  moderate - AI starts, stops, restarts sessions',
      '  full     - Full autonomy, notifies on errors only',
      '',
      'Set: ai level <observe|cautious|moderate|full>',
    ].join('\n');
  }

  // Set the level
  const validLevels = ['observe', 'cautious', 'moderate', 'full'];
  const level = args.toLowerCase().trim();
  if (!validLevels.includes(level)) {
    return `Invalid level "${level}". Valid: ${validLevels.join(', ')}`;
  }

  const s = this.state.load();
  this.state.setAutonomyLevel(s, level);

  const descriptions = {
    observe: 'SMS recommendations only, no actions taken',
    cautious: 'AI can start sessions and send notifications',
    moderate: 'AI can start, stop, and restart sessions',
    full: 'Full autonomy, AI handles everything',
  };

  return `Autonomy level set to: ${level}\n${descriptions[level]}`;
}
```

**Update route() to pass arguments to _handleAiLevel:**
Change the route for `ai level` from:
```javascript
if (lower === 'ai level') return this._handleAiLevel();
```
to:
```javascript
if (lower === 'ai level' || lower.startsWith('ai level ')) {
  const args = lower === 'ai level' ? null : trimmed.slice(9).trim();
  return this._handleAiLevel(args);
}
```

**Update `_handleAiStatus()`** to show the runtime level (not just config):
Replace the `Mode: ${status.autonomyLevel}` line. The getStatus() method on AIBrain reads from config. Instead, read from state:
```javascript
const s = this.state.load();
const level = this.state.getAutonomyLevel(s, this.aiBrain.config);
```
Then display `Mode: ${level}` instead of `Mode: ${status.autonomyLevel}`.

**Update `_handleAiHelp()`** to mention level setting:
Change `"ai level - show autonomy level"` to `"ai level [observe|cautious|moderate|full] - show/set autonomy"`.

**Update `_handleHelp()`** AI section:
Change `"AI: ai on/off | think | status | explain | level"` to `"AI: on/off | think | status | explain | level <set>"`.
  </action>
  <verify>
- The route for `ai level cautious` hits `_handleAiLevel('cautious')` and returns a success message
- `ai level` with no args shows current level and options
- `ai level invalid` returns an error message with valid options
- `ai status` shows the runtime autonomy level
- Help menus mention level setting
- All existing commands still work (status, start, stop, etc.)
  </verify>
  <done>
- `ai level` with no args shows current level and all options
- `ai level observe|cautious|moderate|full` sets the level and persists to .state.json
- `ai level <invalid>` returns error with valid options
- `ai status` reflects the runtime autonomy level (not just config default)
- Help menus updated to show level setting capability
- Backward compatible -- state without runtimeAutonomyLevel defaults to config value
  </done>
</task>

</tasks>

<verification>
1. Autonomy gating: observe blocks all actions, cautious allows start+notify, moderate allows start/stop/restart/notify, full allows everything
2. Preconditions: starting an already-running project is rejected, stopping a non-running project is rejected
3. `ai level cautious` persists to .state.json and subsequent `ai level` reads it back
4. All existing SMS commands work identically
5. Zero new npm dependencies
</verification>

<success_criteria>
- DecisionExecutor.execute() dispatches real actions through sessionManager
- Autonomy level gating prevents unauthorized actions per level
- Just-in-time preconditions catch stale state before execution
- Error retry cap prevents infinite restart loops
- AI level SMS command works for read and write
- All execution results logged to state.executionHistory
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-autonomous-execution-and-intelligence/02-02-SUMMARY.md`
</output>
