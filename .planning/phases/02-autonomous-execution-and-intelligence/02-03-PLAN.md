---
phase: 02-autonomous-execution-and-intelligence
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - lib/context-assembler.js
  - index.js
autonomous: true

must_haves:
  truths:
    - "Stale projects are flagged with days-since-activity in AI context prompt"
    - "Error history for projects with recent errors appears in the context prompt"
    - "AI response schema accepts optional prompt, confidence, and notificationTier fields"
    - "Sessions running longer than maxSessionDurationMs are automatically stopped"
    - "Timeout notifications are sent when sessions are stopped for exceeding the time limit"
  artifacts:
    - path: "lib/context-assembler.js"
      provides: "Enhanced context with staleness, error history, and expanded response format"
      contains: "STALE"
    - path: "index.js"
      provides: "Session timeout scan in proactive loop"
      contains: "checkSessionTimeouts"
  key_links:
    - from: "lib/context-assembler.js"
      to: "lib/scanner.js"
      via: "reads lastActivity from scanner data for staleness computation"
      pattern: "lastActivity|daysSince|stale"
    - from: "index.js"
      to: "lib/session-manager.js"
      via: "timeout scan calls getActiveSessions() and stopSession()"
      pattern: "sessionManager\\.(getActiveSessions|stopSession)"
---

<objective>
Enrich the AI context prompt with staleness detection, error history, and expanded response schema. Add session time boxing to prevent runaway sessions.

Purpose: The AI makes better decisions with richer context (staleness, errors, custom prompts), and time boxing is a critical safety mechanism for autonomous operation -- without it, a stuck session blocks a slot indefinitely.

Output: Enhanced context-assembler.js with staleness/error/prompt fields, and a timeout scan function in index.js.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-RESEARCH.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-01-SUMMARY.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-02-SUMMARY.md
@lib/context-assembler.js
@lib/session-manager.js
@index.js
@config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich context-assembler with staleness, error history, and expanded response schema</name>
  <files>lib/context-assembler.js</files>
  <action>
Enhance the ContextAssembler to provide richer context for better AI decisions.

**1. Staleness detection in `_formatProject()`:**

Add staleness computation to the project formatting. After the existing `if (project.lastActivity)` block, compute days since activity:

```javascript
if (project.lastActivity) {
  const lastDate = new Date(project.lastActivity);
  const daysSince = Math.round((Date.now() - lastDate.getTime()) / 86400000);
  const stalenessDays = this.config.ai?.stalenessDays || 3;
  if (daysSince >= stalenessDays && project.status && !project.status.toLowerCase().includes('complete')) {
    parts.push(`  STALE (${daysSince} days idle)`);
  }
  parts.push(`  Last: ${project.lastActivity}`);
} else if (project.lastActivity) {
  parts.push(`  Last: ${project.lastActivity}`);
}
```

Wait -- the existing code already has `if (project.lastActivity) { parts.push(...) }`. Replace that block with:

```javascript
if (project.lastActivity) {
  const lastDate = new Date(project.lastActivity);
  const daysSince = Math.round((Date.now() - lastDate.getTime()) / 86400000);
  const stalenessDays = this.config.ai?.stalenessDays || 3;
  const isStale = daysSince >= stalenessDays && project.status && !project.status.toLowerCase().includes('complete');
  if (isStale) {
    parts.push(`  STALE (${daysSince} days idle)`);
  }
  parts.push(`  Last: ${project.lastActivity}`);
}
```

**2. Error history in project context:**

Add error signal data to `_formatProject()`. The method needs access to signal data. Change the method signature to accept an optional `errorInfo` parameter:

```javascript
_formatProject(project, hasSession, note, errorInfo) {
  // ... existing code ...

  // After the note section, add error info
  if (errorInfo) {
    parts.push(`  ERROR: ${errorInfo.error || 'unknown error'}`);
    if (errorInfo.retryCount > 0) {
      const maxRetries = this.config.ai?.maxErrorRetries || 3;
      parts.push(`  Retries: ${errorInfo.retryCount}/${maxRetries}`);
    }
  }

  // ... rest of existing code ...
}
```

Update `_buildProjectsSection()` to gather error info from state and signal files:

```javascript
_buildProjectsSection(projects, sessionSet, priorities) {
  const lines = [`Projects (${projects.length}):`];

  // Load error retry counts from state
  const stateData = this.state.load();
  const errorCounts = stateData.errorRetryCounts || {};

  for (const p of projects) {
    const note = priorities.notes?.[p.name];
    const errorInfo = this._getProjectErrorInfo(p.name, errorCounts);
    lines.push('');
    lines.push(this._formatProject(p, sessionSet.has(p.name), note, errorInfo));
  }

  return lines.join('\n');
}
```

Add `_getProjectErrorInfo()`:

```javascript
_getProjectErrorInfo(projectName, errorCounts) {
  const retryCount = errorCounts[projectName] || 0;

  // Check for active error signal file
  const fs = require('fs');
  const path = require('path');
  const errorFile = path.join(this.config.projectsDir || this.scanner?.projectsDir || '/Users/claude/projects', projectName, '.orchestrator', 'error.json');
  let errorData = null;
  try {
    if (fs.existsSync(errorFile)) {
      errorData = JSON.parse(fs.readFileSync(errorFile, 'utf-8'));
    }
  } catch {}

  if (!errorData && retryCount === 0) return null;

  return {
    error: errorData?.error || (retryCount > 0 ? 'previous error (retried)' : null),
    retryCount,
  };
}
```

Wait -- `fs` and `path` are already required at the top of the file. Good.

**3. Expanded response format:**

Update `_buildResponseFormat()` to include the new optional fields Phase 2 adds to recommendations. Replace the existing method body:

```javascript
_buildResponseFormat() {
  // Load runtime autonomy level
  const stateData = this.state.load();
  const autonomyLevel = this.state.getAutonomyLevel
    ? this.state.getAutonomyLevel(stateData, this.config)
    : (this.config.ai?.autonomyLevel || 'observe');

  const lines = [
    'Respond with a JSON object in this exact format:',
    '{',
    '  "recommendations": [',
    '    {',
    '      "project": "project-name",',
    '      "action": "start|stop|restart|notify|skip",',
    '      "reason": "why this action",',
    '      "priority": 1-5,',
    '      "message": "SMS text if action is notify",',
    '      "prompt": "optional: specific instructions for the Claude Code session (for start/restart)",',
    '      "confidence": 0.85,',
    '      "notificationTier": 2',
    '    }',
    '  ],',
    '  "summary": "One-line overall assessment",',
    '  "nextThinkIn": "suggested seconds until next think cycle"',
    '}',
    '',
    `Current autonomy level: ${autonomyLevel}`,
    autonomyLevel === 'observe'
      ? 'You are in OBSERVE mode. Recommend actions but none will be executed automatically.'
      : `You are in ${autonomyLevel.toUpperCase()} mode. Actions will be executed automatically based on your recommendations.`,
    '',
    'Rules:',
    '- Only recommend actions for projects not in the block list',
    '- Focus on projects in the focus list first',
    '- Prioritize STALE projects that have pending work',
    '- Do not repeat an action for the same project if it appears in recent decisions',
    '- If nothing needs doing, return empty recommendations and suggest a longer nextThinkIn',
    '- priority: 1=critical, 2=high, 3=medium, 4=low, 5=informational',
    '- For start/restart actions, include a specific "prompt" field with targeted instructions for the session',
    '- For projects with errors, evaluate if the error is retryable or needs human intervention',
    '- If error retry count is at the cap, recommend "notify" to escalate to the user instead of restart',
  ];

  return lines.join('\n');
}
```

**4. Session duration in sessions section:**

Update `_buildSessionsSection()` to show how long each session has been running:

```javascript
_buildSessionsSection(sessions) {
  const maxConcurrent = this.config.maxConcurrentSessions || 5;
  const maxDuration = this.config.ai?.maxSessionDurationMs || 2700000;
  const lines = [`Active Sessions (${sessions.length}/${maxConcurrent}):`];

  if (sessions.length === 0) {
    lines.push('None running.');
  } else {
    for (const s of sessions) {
      const startTime = new Date(s.created).getTime();
      const durationMin = Math.round((Date.now() - startTime) / 60000);
      const maxMin = Math.round(maxDuration / 60000);
      const timeWarning = durationMin >= maxMin ? ' TIMEOUT IMMINENT' : '';
      lines.push(`- ${s.projectName} (${durationMin}min running${timeWarning})`);
    }
  }

  return lines.join('\n');
}
```
  </action>
  <verify>
- `node -e "const CA = require('./lib/context-assembler'); console.log(typeof CA)"` prints `function`
- All existing modules load: `node -e "require('./lib/commands'); require('./lib/ai-brain'); require('./lib/context-assembler'); console.log('OK')"`
- Grep context-assembler.js for `STALE` -- should find the staleness flag
- Grep context-assembler.js for `prompt.*optional` -- should find the new response format field
- Grep context-assembler.js for `TIMEOUT IMMINENT` -- should find session duration warning
  </verify>
  <done>
- Stale projects flagged with `STALE (N days idle)` in the AI prompt context
- Error history (error message + retry count) shown per project in context
- Response format includes optional prompt, confidence, notificationTier fields
- Autonomy level communicated to AI in the response format section
- Session durations shown in minutes with timeout warnings
- Error retry guidance in response format rules
- All existing functionality preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session time boxing scan to the proactive loop</name>
  <files>index.js</files>
  <action>
Add a `checkSessionTimeouts()` function that runs alongside `proactiveScan()` to enforce session time limits.

**Add `checkSessionTimeouts()` function** (place it after the `proactiveScan()` function definition, before the message polling section):

```javascript
function checkSessionTimeouts() {
  const maxDurationMs = CONFIG.ai?.maxSessionDurationMs || 2700000; // 45 min default

  try {
    const sessions = sessionManager.getActiveSessions();

    for (const session of sessions) {
      const startTime = new Date(session.created).getTime();
      const duration = Date.now() - startTime;

      if (duration > maxDurationMs) {
        const durationMin = Math.round(duration / 60000);
        log('TIMEOUT', `Session ${session.projectName} exceeded ${Math.round(maxDurationMs / 60000)}min (running ${durationMin}min), stopping...`);

        // Capture last output before stopping (best-effort)
        let lastOutput = '';
        try {
          const rawOutput = require('child_process').execSync(
            `tmux capture-pane -t "${session.name}" -p 2>/dev/null | tail -5`,
            { encoding: 'utf-8', timeout: 5000 }
          );
          lastOutput = rawOutput.trim().substring(0, 300);
        } catch {}

        // Stop the session
        const result = sessionManager.stopSession(session.projectName);

        // Notify (use notificationManager if available, else messenger)
        const notification = `Session ${session.projectName} timed out after ${durationMin}min.${lastOutput ? '\n\nLast output:\n' + lastOutput : ''}`;

        if (typeof notificationManager !== 'undefined' && notificationManager) {
          notificationManager.notify(notification, 2); // tier 2 = action
        } else {
          messenger.send(notification);
        }

        log('TIMEOUT', `Stopped ${session.projectName}: ${result.message}`);
      }
    }
  } catch (e) {
    log('TIMEOUT', `Error checking timeouts: ${e.message}`);
  }
}
```

**Wire `checkSessionTimeouts` into the scan interval:**

In the startup section where `scanInterval` is created, change:
```javascript
const scanInterval = setInterval(proactiveScan, CONFIG.scanIntervalMs);
```
to:
```javascript
const scanInterval = setInterval(() => {
  proactiveScan();
  checkSessionTimeouts();
}, CONFIG.scanIntervalMs);
```

This runs the timeout check every 60 seconds (same as proactive scan), which is frequent enough to catch timeouts within 1 minute of the limit.

**Also add the `notificationManager` initialization** in the AI Brain section of index.js. Place it right after the `decisionExecutor` initialization:

```javascript
const NotificationManager = require('./lib/notification-manager');
const notificationManager = new NotificationManager({
  messenger,
  config: CONFIG,
  scheduler,
});
```

**Update the DecisionExecutor initialization** to pass the new deps:

```javascript
const decisionExecutor = new DecisionExecutor({
  sessionManager,
  messenger,
  notificationManager,
  signalProtocol,
  state,
  config: CONFIG,
});
```

**Start the batch timer** at boot (near the bottom, after `startThinkCycle()`):

```javascript
notificationManager.startBatchTimer();
```

**Update shutdown** to stop the batch timer:

```javascript
function shutdown(signal) {
  log('SHUTDOWN', `Received ${signal}, stopping orchestrator...`);
  log('SHUTDOWN', 'Note: Managed tmux sessions will continue running independently.');
  clearInterval(msgInterval);
  clearInterval(scanInterval);
  if (thinkInterval) clearInterval(thinkInterval);
  notificationManager.stopBatchTimer();
  scheduler.stop();
  process.exit(0);
}
```

Do NOT change the think cycle dispatch in index.js yet -- that wiring happens in Plan 04.
  </action>
  <verify>
- `node -e "console.log('index.js parses OK')"` after adding changes
- Grep index.js for `checkSessionTimeouts` -- should find the function definition and its call in setInterval
- Grep index.js for `NotificationManager` -- should find the import and initialization
- Grep index.js for `notificationManager.stopBatchTimer` -- should find it in shutdown
- All existing startup behavior preserved (banner, initial scan, message polling)
  </verify>
  <done>
- checkSessionTimeouts() function scans active sessions every 60 seconds
- Sessions exceeding maxSessionDurationMs are stopped with last-output capture
- Timeout notifications sent via notificationManager (tier 2)
- NotificationManager initialized in index.js and wired to decisionExecutor
- Batch timer started at boot and stopped on shutdown
- All existing scan/poll behavior preserved
  </done>
</task>

</tasks>

<verification>
1. Context assembler produces prompts with STALE flags for old projects
2. Context assembler includes error info when error signals exist
3. Response format shows current autonomy level and expanded fields
4. Session timeout scan stops sessions exceeding the configured limit
5. NotificationManager integrated into index.js initialization
6. All existing modules load and function correctly
7. Zero new npm dependencies
</verification>

<success_criteria>
- AI context includes staleness flags, error history, session durations
- Response format includes prompt/confidence/notificationTier optional fields
- Sessions are automatically stopped after maxSessionDurationMs
- Timeout notifications sent with last output captured
- NotificationManager wired into the main orchestrator
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-autonomous-execution-and-intelligence/02-03-SUMMARY.md`
</output>
