---
phase: 02-autonomous-execution-and-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/notification-manager.js
  - config.json
  - lib/state.js
autonomous: true

must_haves:
  truths:
    - "NotificationManager routes messages to correct tier (urgent sends immediately, debug logs only)"
    - "Daily SMS budget caps outgoing messages and urgent bypasses the budget"
    - "Tier 3 messages batch into a queue and flush on interval or piggyback"
    - "Config.json has all Phase 2 AI settings (maxSessionDurationMs, maxErrorRetries, stalenessDays, notifications)"
    - "State.js tracks stateVersion, execution history, error retry counts, and runtime autonomy level"
  artifacts:
    - path: "lib/notification-manager.js"
      provides: "Tier-based notification routing, batching, daily budget"
      min_lines: 80
    - path: "config.json"
      provides: "Phase 2 AI configuration fields"
      contains: "maxSessionDurationMs"
    - path: "lib/state.js"
      provides: "State extensions for Phase 2"
      contains: "stateVersion"
  key_links:
    - from: "lib/notification-manager.js"
      to: "lib/messenger.js"
      via: "wraps messenger.send() for tier 1-2 delivery"
      pattern: "messenger\\.send"
    - from: "lib/state.js"
      to: ".state.json"
      via: "persists stateVersion, executionHistory, errorRetryCounts, runtimeAutonomyLevel"
      pattern: "stateVersion|executionHistory|errorRetry"
---

<objective>
Build the foundation layer that all Phase 2 features depend on: notification tier system, config additions, and state extensions.

Purpose: Every Phase 2 feature (executor wiring, time boxing, error recovery, digest) needs notification tiers, extended config, and enriched state. Building these first prevents circular dependencies.

Output: Three artifacts -- NotificationManager class wrapping messenger, extended config.json with Phase 2 fields, extended state.js with version tracking and execution history.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-RESEARCH.md
@.planning/phases/01-ai-brain-foundation/01-01-SUMMARY.md
@lib/messenger.js
@lib/state.js
@config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationManager and extend config.json</name>
  <files>lib/notification-manager.js, config.json</files>
  <action>
Create `lib/notification-manager.js` -- a new class that wraps the existing Messenger to add tier routing, batching, and daily SMS budgeting.

Constructor takes `{ messenger, config, scheduler }` (scheduler for quiet hours check).

**Tier constants:**
- URGENT (1): Send immediately, bypass quiet hours if `config.ai.notifications.urgentBypassQuiet` is true. Always bypass daily budget.
- ACTION (2): Send immediately during non-quiet hours. Queue for wake if quiet. Counts against daily budget.
- SUMMARY (3): Add to batch queue. Flush every `config.ai.notifications.batchIntervalMs` (default 4 hours) or piggyback when a tier 1/2 message goes out.
- DEBUG (4): console.log only, never SMS.

**Key methods:**
- `notify(text, tier = 2)` -- main entry point. Routes based on tier.
- `_sendImmediate(text)` -- calls `messenger.send(text)`, increments `_dailySentCount`.
- `_addToBatch(text)` -- pushes to `_batchQueue` array.
- `_flushBatch()` -- if `_batchQueue.length > 0`, format as "Batch update (N items):\n- item1\n- item2\n..." and send via `_sendImmediate()`. Clear queue. Truncate batch SMS to 1500 chars.
- `_checkBudget()` -- returns `{ ok: boolean, remaining: number }`. Budget = `config.ai.notifications.dailyBudget` (default 20). Resets at midnight (track `_budgetResetDate`).
- `getStats()` -- returns `{ dailySent, dailyBudget, batchQueueSize, budgetRemaining }`.
- `startBatchTimer()` -- sets interval for `_flushBatch()` at `batchIntervalMs`. Returns the interval ID for cleanup.
- `stopBatchTimer()` -- clears the interval.

**Budget enforcement:**
- Tier 1 (URGENT): Always sends, even if over budget.
- Tier 2 (ACTION): If budget exhausted, downgrade to batch (tier 3).
- Tier 3 (SUMMARY): No budget cost until batch flushes (counts as 1 SMS).
- Log warning when budget hits 80%.

**Config additions to config.json:**
Add these fields inside the `ai` section:

```json
"maxSessionDurationMs": 2700000,
"maxErrorRetries": 3,
"stalenessDays": 3,
"notifications": {
  "dailyBudget": 20,
  "batchIntervalMs": 14400000,
  "urgentBypassQuiet": true
}
```

Do NOT modify any existing config fields. Only add the new ones inside the `ai` object.

Zero new npm dependencies.
  </action>
  <verify>
- `node -e "const NM = require('./lib/notification-manager'); console.log(typeof NM)"` prints `function`
- `node -e "const c = require('./config.json'); console.log(c.ai.maxSessionDurationMs, c.ai.notifications.dailyBudget)"` prints `2700000 20`
- Smoke test: instantiate NotificationManager with mock messenger, call `notify('test', 4)` (debug) -- should NOT call messenger.send. Call `notify('urgent', 1)` -- should call messenger.send.
  </verify>
  <done>
- NotificationManager class exports correctly with all methods: notify, getStats, startBatchTimer, stopBatchTimer
- config.json has maxSessionDurationMs, maxErrorRetries, stalenessDays, and notifications subsection
- Tier routing works: debug=log-only, urgent=immediate, action=immediate-if-non-quiet, summary=batch
- Daily budget enforcement with tier 1 bypass
- Zero new npm dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend state.js with version tracking, execution history, and error retry counts</name>
  <files>lib/state.js</files>
  <action>
Extend the existing StateManager class with Phase 2 state fields. Do NOT break backward compatibility -- all new fields have defaults in `load()`.

**1. State version counter:**
Add `stateVersion` field. Default to 0 in `load()`.
Add method `incrementVersion(state)` -- increments `state.stateVersion`, calls `this.save(state)`, returns the new version.
Modify `save(state)` to auto-increment stateVersion if not explicitly set (add `state.stateVersion = (state.stateVersion || 0) + 1` at start of save).

Actually, simpler approach: just add `incrementVersion(state)` that bumps and saves. Don't modify save() itself -- that would cause double-increments since other methods call save(). Instead, callers who want version tracking call `incrementVersion()` explicitly.

**2. Execution history:**
Add `executionHistory` array field. Default to `[]` in `load()`.
Add method `logExecution(state, executionRecord)`:
- Pushes to `state.executionHistory`
- Trims to last 100 entries
- Calls `this.save(state)`

Execution record shape: `{ timestamp, action, project, result, autonomyLevel, stateVersion }`

**3. Error retry counts:**
Add `errorRetryCounts` object field. Default to `{}` in `load()`.
Add method `recordErrorRetry(state, project)`:
- Increments `state.errorRetryCounts[project] = (state.errorRetryCounts[project] || 0) + 1`
- Saves state
- Returns current count

Add method `getErrorRetryCount(state, project)`:
- Returns `state.errorRetryCounts[project] || 0`

Add method `clearErrorRetries(state, project)`:
- Deletes `state.errorRetryCounts[project]`
- Saves state

**4. Runtime autonomy level override:**
Add `runtimeAutonomyLevel` field. Default to `null` in `load()` (meaning: use config default).
Add method `setAutonomyLevel(state, level)`:
- Validates level is one of: 'observe', 'cautious', 'moderate', 'full'
- Sets `state.runtimeAutonomyLevel = level`
- Saves state
- Returns level

Add method `getAutonomyLevel(state, config)`:
- Returns `state.runtimeAutonomyLevel || config.ai?.autonomyLevel || 'observe'`

**Backward compatibility:** The `load()` method's default state object must include all new fields with safe defaults:
```javascript
return {
  lastRowId: 0,
  lastScan: null,
  lastDigest: null,
  alertHistory: {},
  aiDecisionHistory: [],
  stateVersion: 0,
  executionHistory: [],
  errorRetryCounts: {},
  runtimeAutonomyLevel: null,
};
```
  </action>
  <verify>
- `node -e "const S = require('./lib/state'); const s = new S('/tmp/test-state.json'); const st = s.load(); console.log(st.stateVersion, st.executionHistory.length, st.runtimeAutonomyLevel)"` prints `0 0 null`
- `node -e "const S = require('./lib/state'); const s = new S('/tmp/test-state2.json'); const st = s.load(); s.incrementVersion(st); console.log(st.stateVersion)"` prints `1`
- `node -e "const S = require('./lib/state'); const s = new S('/tmp/test-state3.json'); const st = s.load(); s.logExecution(st, {action:'start',project:'test',timestamp:new Date().toISOString()}); console.log(st.executionHistory.length)"` prints `1`
- All existing modules load without error: `node -e "require('./index')"` (will fail to start due to iMessage but should not throw import errors)
  </verify>
  <done>
- state.js has stateVersion counter with incrementVersion() method
- executionHistory array with logExecution() method (capped at 100)
- errorRetryCounts with recordErrorRetry(), getErrorRetryCount(), clearErrorRetries()
- runtimeAutonomyLevel with setAutonomyLevel() and getAutonomyLevel()
- Backward compatible -- existing .state.json files load without errors
- All existing orchestrator modules still import and function correctly
  </done>
</task>

</tasks>

<verification>
1. `node -e "const NM = require('./lib/notification-manager'); const S = require('./lib/state'); console.log('both load OK')"` -- both modules import cleanly
2. config.json is valid JSON with all new fields present
3. All existing modules continue to load: `node -e "require('./lib/commands'); require('./lib/ai-brain'); require('./lib/decision-executor'); require('./lib/context-assembler'); require('./lib/state'); console.log('all modules OK')"`
4. Zero new npm dependencies
</verification>

<success_criteria>
- NotificationManager class routes tier 1/2/3/4 correctly
- Daily SMS budget enforcement with urgent bypass
- Batch queue accumulates tier 3 messages and flushes on interval
- Config.json has all Phase 2 fields
- State.js tracks version, execution history, error retries, runtime autonomy level
- Full backward compatibility with existing .state.json files
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-autonomous-execution-and-intelligence/02-01-SUMMARY.md`
</output>
