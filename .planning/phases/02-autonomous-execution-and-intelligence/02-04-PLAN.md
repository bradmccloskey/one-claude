---
phase: 02-autonomous-execution-and-intelligence
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - lib/ai-brain.js
  - index.js
autonomous: true

must_haves:
  truths:
    - "AI think cycle dispatches execution to DecisionExecutor.execute() for non-observe autonomy levels"
    - "Morning digest is AI-generated via claude -p with fallback to the template digest"
    - "AI digest includes overnight decision history and session activity"
    - "Think cycle respects nextThinkIn suggestions from AI response (within bounds)"
    - "Observe mode still sends SMS-only recommendations (Phase 1 behavior preserved)"
  artifacts:
    - path: "lib/ai-brain.js"
      provides: "generateDigest() method and execution dispatch integration"
      contains: "generateDigest"
    - path: "index.js"
      provides: "Think cycle execution dispatch, AI digest replacement, nextThinkIn override"
      contains: "decisionExecutor.execute"
  key_links:
    - from: "index.js"
      to: "lib/decision-executor.js"
      via: "think cycle calls execute() for each validated recommendation"
      pattern: "decisionExecutor\\.execute"
    - from: "lib/ai-brain.js"
      to: "lib/context-assembler.js"
      via: "generateDigest() uses context assembler for overnight activity"
      pattern: "contextAssembler\\.assemble"
    - from: "index.js"
      to: "lib/ai-brain.js"
      via: "sendDigest() calls aiBrain.generateDigest() with template fallback"
      pattern: "aiBrain\\.generateDigest|digest\\.formatMorningDigest"
---

<objective>
Complete the Phase 2 integration by wiring execution dispatch into the think cycle, replacing the template morning digest with AI-generated content, and honoring AI-suggested think intervals.

Purpose: This is the final wiring plan that connects all Phase 2 components. After this plan, the orchestrator can autonomously execute AI decisions, generate intelligent digests, and adaptively pace its think cycles.

Output: Updated ai-brain.js with generateDigest(), and index.js with full execution dispatch in think cycle and AI digest integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-RESEARCH.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-01-SUMMARY.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-02-SUMMARY.md
@.planning/phases/02-autonomous-execution-and-intelligence/02-03-SUMMARY.md
@lib/ai-brain.js
@lib/decision-executor.js
@lib/context-assembler.js
@index.js
@lib/digest.js
@config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generateDigest() to AIBrain and update think cycle in index.js</name>
  <files>lib/ai-brain.js, index.js</files>
  <action>

### Part A: Add generateDigest() to AIBrain (lib/ai-brain.js)

Add a `generateDigest()` method that produces an AI-written morning digest via `claude -p`. This replaces the template-based digest when AI is available.

```javascript
/**
 * Generate an AI-written morning digest via claude -p.
 * Includes overnight activity, session completions, errors, and priorities.
 *
 * @returns {string|null} AI-generated digest text, or null on failure
 */
async generateDigest() {
  if (this._thinking) {
    console.log('[ai-brain] Cannot generate digest while thinking');
    return null;
  }

  this._thinking = true;
  try {
    // Gather context
    const baseContext = this.contextAssembler.assemble();

    // Get overnight decision history
    const s = this.state.load();
    const history = s.aiDecisionHistory || [];
    const executionHistory = s.executionHistory || [];

    // Filter to decisions from last 12 hours (overnight window)
    const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000);
    const recentDecisions = history.filter(d => new Date(d.timestamp).getTime() > twelveHoursAgo);
    const recentExecutions = executionHistory.filter(e => new Date(e.timestamp).getTime() > twelveHoursAgo);

    // Build digest prompt
    const digestPrompt = [
      'You are generating a morning digest for a project orchestrator manager.',
      'Write a concise, valuable summary (under 1000 chars) that covers:',
      '1. What happened overnight (sessions started/stopped, completions, errors)',
      '2. What needs attention today',
      '3. Suggested priorities for today',
      '',
      'Keep it conversational and actionable. No JSON needed, just plain text.',
      'Start with "Good morning!" and end with today\'s top priority.',
      '',
      '--- Current State ---',
      baseContext.substring(0, 4000),  // First 4K of context
      '',
    ];

    if (recentDecisions.length > 0) {
      digestPrompt.push('--- Overnight AI Decisions ---');
      for (const d of recentDecisions.slice(-10)) {
        digestPrompt.push(`[${d.timestamp}] ${d.summary || 'no summary'}`);
        if (d.recommendations) {
          for (const r of d.recommendations) {
            digestPrompt.push(`  - ${r.action} ${r.project}: ${r.reason || ''}`);
          }
        }
      }
      digestPrompt.push('');
    }

    if (recentExecutions.length > 0) {
      digestPrompt.push('--- Overnight Executions ---');
      for (const e of recentExecutions.slice(-10)) {
        digestPrompt.push(`[${e.timestamp}] ${e.action} ${e.project}: ${e.result?.message || ''}`);
      }
      digestPrompt.push('');
    }

    const prompt = digestPrompt.join('\n');

    // Shell out to claude -p
    const model = this.config.ai?.model || 'sonnet';
    const responseText = execSync(
      `claude -p --model ${model} --max-turns 1 --output-format text`,
      { input: prompt, encoding: 'utf-8', timeout: 30000 }
    );

    const digestText = responseText.trim();
    if (digestText.length < 20) {
      console.log('[ai-brain] Digest response too short, likely failed');
      return null;
    }

    // Truncate if over 1500 chars (SMS limit)
    return digestText.length > 1500 ? digestText.substring(0, 1460) + '\n\n[truncated]' : digestText;

  } catch (err) {
    console.log(`[ai-brain] Digest generation failed: ${err.message}`);
    return null;
  } finally {
    this._thinking = false;
  }
}
```

Also add a `_nextThinkOverride` field to the constructor:
```javascript
this._nextThinkOverride = null;  // AI-suggested think interval override
```

Add getter/setter for the override:
```javascript
/**
 * Set an override for the next think interval (in ms).
 * Bounded to 60s-1800s (1-30 min). Resets after one use.
 * @param {number} seconds - AI-suggested seconds
 */
setNextThinkOverride(seconds) {
  const bounded = Math.max(60, Math.min(1800, Number(seconds) || 300));
  this._nextThinkOverride = bounded * 1000;
}

/**
 * Consume the next think override (returns it and resets to null).
 * @returns {number|null} Override in ms, or null
 */
consumeNextThinkOverride() {
  const override = this._nextThinkOverride;
  this._nextThinkOverride = null;
  return override;
}
```

### Part B: Wire execution dispatch and AI digest into index.js

**1. Update the think cycle** to dispatch executions instead of just sending SMS recommendations.

Replace the entire `startThinkCycle()` function:

```javascript
let thinkInterval = null;
let nextThinkTimeoutMs = null;

function startThinkCycle() {
  if (thinkInterval) return;
  const defaultIntervalMs = CONFIG.ai?.thinkIntervalMs || 300000;

  function scheduleNextThink() {
    const intervalMs = nextThinkTimeoutMs || defaultIntervalMs;
    nextThinkTimeoutMs = null;  // Reset override

    thinkInterval = setTimeout(async () => {
      if (!aiBrain.isEnabled()) {
        scheduleNextThink();
        return;
      }
      if (scheduler.isQuietTime()) {
        scheduleNextThink();
        return;
      }

      try {
        log('AI', 'Starting think cycle...');
        const decision = await aiBrain.think();

        if (decision && decision.recommendations?.length > 0) {
          const evaluated = decision.evaluated || decisionExecutor.evaluate(decision.recommendations);

          // Get runtime autonomy level
          const s = state.load();
          const autonomyLevel = state.getAutonomyLevel(s, CONFIG);

          if (autonomyLevel === 'observe') {
            // Observe mode: SMS only (Phase 1 behavior)
            const sms = decisionExecutor.formatForSMS(evaluated, decision.summary);
            notificationManager.notify(sms, 3);  // tier 3 = summary
          } else {
            // Active mode: execute validated recommendations
            for (const rec of evaluated) {
              if (!rec.validated) continue;

              try {
                const result = await decisionExecutor.execute(rec);
                log('AI', `Executed: ${rec.action} ${rec.project} -> ${result.executed ? 'success' : 'rejected: ' + (result.rejected || result.result?.message)}`);
              } catch (execErr) {
                log('AI', `Execution error for ${rec.project}: ${execErr.message}`);
              }
            }
          }

          log('AI', `Think cycle complete: ${decision.recommendations.length} recommendations`);
        } else {
          log('AI', 'Think cycle complete: no recommendations');
        }

        // Honor nextThinkIn if AI suggested one
        if (decision?.nextThinkIn) {
          const suggestedSeconds = parseInt(decision.nextThinkIn, 10);
          if (!isNaN(suggestedSeconds) && suggestedSeconds > 0) {
            aiBrain.setNextThinkOverride(suggestedSeconds);
            const override = aiBrain.consumeNextThinkOverride();
            if (override) {
              nextThinkTimeoutMs = override;
              log('AI', `Next think in ${Math.round(override / 1000)}s (AI suggested)`);
            }
          }
        }

      } catch (e) {
        log('AI', `Think cycle error: ${e.message}`);
      }

      scheduleNextThink();
    }, intervalMs);
  }

  scheduleNextThink();
  log('AI', `Think cycle scheduled (default ${defaultIntervalMs / 1000}s, AI may adjust)`);
}
```

Note: Changed from `setInterval` to recursive `setTimeout` to support variable intervals from the AI's `nextThinkIn` suggestions. The old `clearInterval(thinkInterval)` in shutdown still works since `clearTimeout` and `clearInterval` are functionally the same in Node.js for timer IDs.

**2. Update `sendDigest()` to use AI-generated digest with template fallback:**

```javascript
async function sendDigest() {
  try {
    // Try AI-generated digest first
    if (aiBrain.isEnabled()) {
      log('DIGEST', 'Generating AI digest...');
      const aiDigest = await aiBrain.generateDigest();
      if (aiDigest) {
        messenger.send(aiDigest);
        const s = state.load();
        s.lastDigest = new Date().toISOString();
        state.save(s);
        log('DIGEST', 'Sent AI-generated morning digest');
        return;
      }
      log('DIGEST', 'AI digest failed, falling back to template');
    }

    // Fallback to template digest
    const projects = scanner.scanAll();
    const processStatus = processMonitor.checkProjects(CONFIG.projects);
    const text = digest.formatMorningDigest(projects, processStatus);
    messenger.send(text);
    const s = state.load();
    s.lastDigest = new Date().toISOString();
    state.save(s);
    log('DIGEST', 'Sent template morning digest');
  } catch (e) {
    log('DIGEST', `Error: ${e.message}`);
  }
}
```

**3. Update the `_handleAiThink()` in the think cycle dispatch** in commands.js through the same index.js think cycle mechanism. Actually, no -- the commands.js handler already works independently via setTimeout. But we should update it to also dispatch executions for consistency.

Wait -- commands.js is NOT in this plan's files_modified. The commands.js handler for `ai think` uses its own setTimeout and messenger.send, which is fine for a manual trigger. Leave it as-is for now. The autonomous think cycle in index.js handles the execution dispatch. Manual `ai think` is a one-shot that doesn't need to auto-execute.

Actually, let's make one small change: the `_handleAiThink()` in commands.js should also dispatch executions when autonomy level allows. But that means touching commands.js which is owned by Plan 02. The executor is already in the deps. Let me include this as a minor addition.

No -- keep it simple. The manual `ai think` is an observe-mode diagnostic. Users who want autonomous execution have it running in the background via the think cycle. Leave `_handleAiThink` as-is.
  </action>
  <verify>
- `node -e "const AB = require('./lib/ai-brain'); console.log(typeof AB.prototype.generateDigest)"` prints `function`
- Grep index.js for `decisionExecutor.execute` -- should find it in the think cycle
- Grep index.js for `aiBrain.generateDigest` -- should find it in sendDigest()
- Grep index.js for `scheduleNextThink` -- should find the recursive setTimeout pattern
- Grep index.js for `nextThinkIn` -- should find the AI override handling
- Grep ai-brain.js for `generateDigest` -- should find the method
- Grep ai-brain.js for `_nextThinkOverride` -- should find the field
- All modules load: `node -e "require('./lib/ai-brain'); require('./lib/decision-executor'); require('./lib/context-assembler'); console.log('OK')"`
  </verify>
  <done>
- AI think cycle dispatches execution for non-observe autonomy levels
- Each validated recommendation is executed via decisionExecutor.execute()
- Observe mode preserves Phase 1 behavior (SMS-only recommendations)
- Morning digest is AI-generated when AI is enabled, with template fallback
- AI digest includes overnight decision and execution history
- nextThinkIn from AI response overrides the think interval (bounded 60s-1800s)
- Think cycle uses recursive setTimeout for variable intervals
- All execution results logged via decisionExecutor
- Shutdown properly clears the think timeout
  </done>
</task>

</tasks>

<verification>
1. With autonomy=cautious and a start recommendation, the think cycle calls `decisionExecutor.execute()` which calls `sessionManager.startSession()`
2. With autonomy=observe, the think cycle sends SMS-only (no execution)
3. Morning digest uses AI when enabled, template when disabled or AI fails
4. nextThinkIn from AI response adjusts the next think interval within bounds
5. All existing functionality preserved (message polling, scan loop, commands)
6. Zero new npm dependencies
</verification>

<success_criteria>
- Think cycle dispatches real execution for cautious/moderate/full autonomy levels
- Observe mode sends SMS recommendations only (Phase 1 parity)
- AI-generated morning digest is sent when available, template on fallback
- AI can adjust its own think interval via nextThinkIn
- Execution results logged to state
- All Phase 2 components connected end-to-end
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-autonomous-execution-and-intelligence/02-04-SUMMARY.md`
</output>
