---
phase: 04-session-intelligence
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - lib/context-assembler.js
  - index.js
autonomous: true

must_haves:
  truths:
    - "AI context prompt includes a system resource line (CPU, RAM, disk)"
    - "AI context prompt includes recent evaluation summaries for projects with sessions in the last 24h"
    - "After a session times out, an evaluation is triggered asynchronously"
    - "After a session ends naturally (detected via signal scan), an evaluation is triggered asynchronously"
    - "Evaluation is only triggered once per session (checked via evaluation.json timestamp)"
  artifacts:
    - path: "lib/context-assembler.js"
      provides: "Resource and evaluation sections in AI context prompt"
      contains: "_buildResourceSection"
    - path: "index.js"
      provides: "Evaluation triggers on session end"
      contains: "sessionEvaluator"
  key_links:
    - from: "lib/context-assembler.js"
      to: "lib/resource-monitor.js"
      via: "resourceMonitor.getSnapshot() + formatForContext()"
      pattern: "resourceMonitor\\.getSnapshot"
    - from: "lib/context-assembler.js"
      to: "lib/state.js"
      via: "state.getRecentEvaluations() for eval summary"
      pattern: "getRecentEvaluations"
    - from: "index.js"
      to: "lib/session-evaluator.js"
      via: "sessionEvaluator.evaluate() called after session stop"
      pattern: "sessionEvaluator\\.evaluate"
---

<objective>
Wire the new modules into the orchestrator: (1) add resource snapshot and evaluation data to the AI context prompt, and (2) trigger session evaluation after sessions end (timeout or natural completion).

Purpose: This is the integration plan that makes everything built in plans 01-03 actually work. Without this wiring, the new modules exist but are never called.
Output: Modified context-assembler.js with two new sections and modified index.js with evaluation triggers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-session-intelligence/04-RESEARCH.md
@lib/context-assembler.js
@index.js
@lib/resource-monitor.js
@lib/git-tracker.js
@lib/session-evaluator.js
@lib/state.js
@lib/session-manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resource and evaluation sections to context-assembler.js</name>
  <files>lib/context-assembler.js</files>
  <action>
**Constructor change:**
Add `resourceMonitor` to the constructor's destructured deps:
```javascript
constructor({ scanner, sessionManager, processMonitor, state, config, resourceMonitor }) {
  // ... existing assignments ...
  this.resourceMonitor = resourceMonitor;
}
```

**New method: _buildResourceSection()** (SESS-04)
```javascript
_buildResourceSection() {
  if (!this.resourceMonitor) return null;
  try {
    const snapshot = this.resourceMonitor.getSnapshot();
    return this.resourceMonitor.formatForContext(snapshot);
  } catch {
    return 'System: resource data unavailable';
  }
}
```

**New method: _buildEvaluationSection()** (SESS-01, SESS-02)
```javascript
_buildEvaluationSection() {
  const stateData = this.state.load();
  const evals = this.state.getRecentEvaluations
    ? this.state.getRecentEvaluations(stateData, 5)
    : [];
  if (evals.length === 0) return null;

  // Only show evals from last 24h
  const cutoff = Date.now() - 24 * 60 * 60 * 1000;
  const recent = evals.filter(e => new Date(e.evaluatedAt).getTime() > cutoff);
  if (recent.length === 0) return null;

  const lines = ['Recent Session Evaluations:'];
  for (const e of recent) {
    lines.push(
      `- ${e.projectName}: ${e.score}/5 (${e.recommendation}) | ` +
      `${e.gitProgress?.commitCount || 0} commits, ` +
      `+${e.gitProgress?.insertions || 0}/-${e.gitProgress?.deletions || 0} lines | ` +
      `${e.durationMinutes || '?'}min`
    );
  }
  return lines.join('\n');
}
```

**Modify assemble():**
Insert the two new sections into the sections array. Add them in this order:
1. After `_buildTimeSection()` (section 2), add `_buildResourceSection()` (new section 2.5)
2. After `_buildProjectsSection()` (section 5), add `_buildEvaluationSection()` (new section 5.5)

Both methods may return null -- filter nulls when building sections:
```javascript
const sections = [];
sections.push(this._buildPreamble(...));
sections.push(this._buildTimeSection());

const resourceSection = this._buildResourceSection();
if (resourceSection) sections.push(resourceSection);

sections.push(this._buildPrioritiesSection(priorities));
sections.push(this._buildSessionsSection(sessions));
sections.push(this._buildProjectsSection(relevantProjects, sessionSet, priorities));

const evalSection = this._buildEvaluationSection();
if (evalSection) sections.push(evalSection);

if (decisionHistory.length > 0) {
  sections.push(this._buildHistorySection(decisionHistory));
}
sections.push(this._buildResponseFormat());
```

Do NOT:
- Change the existing section methods
- Modify the truncation logic (maxLen stays as-is)
- Add git stats inline to _buildProjectsSection (keep it separate -- inline stats would bloat the project list for 19 projects)
  </action>
  <verify>
`grep -n '_buildResourceSection\|_buildEvaluationSection' lib/context-assembler.js` shows both new methods defined and called.
`node -e "require('./lib/context-assembler')"` loads without error.
  </verify>
  <done>
Context assembler includes resource snapshot and recent evaluation summaries in the AI prompt when data is available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire evaluation triggers into index.js</name>
  <files>index.js</files>
  <action>
**Add imports** (near the top, after existing requires):
```javascript
const GitTracker = require('./lib/git-tracker');
const ResourceMonitor = require('./lib/resource-monitor');
const { SessionEvaluator } = require('./lib/session-evaluator');
```

**Instantiate new modules** (after sessionManager creation, before notificationManager):
```javascript
const gitTracker = new GitTracker();
const resourceMonitor = new ResourceMonitor();
```

**Instantiate SessionEvaluator** (after state, config are available):
```javascript
const sessionEvaluator = new SessionEvaluator({
  gitTracker,
  state,
  config: CONFIG,
});
```

**Pass resourceMonitor to ContextAssembler** -- update the contextAssembler constructor call to include `resourceMonitor`:
```javascript
const contextAssembler = new ContextAssembler({
  scanner,
  sessionManager,
  processMonitor,
  state,
  config: CONFIG,
  resourceMonitor,  // NEW
});
```

**Create evaluateSession helper function** (above checkSessionTimeouts):
```javascript
async function evaluateSession(projectName) {
  try {
    const projectDir = path.join(CONFIG.projectsDir, projectName);
    const sessionFile = path.join(projectDir, '.orchestrator', 'session.json');
    if (!fs.existsSync(sessionFile)) {
      log('EVAL', `No session.json for ${projectName}, skipping evaluation`);
      return;
    }

    const sessionData = JSON.parse(fs.readFileSync(sessionFile, 'utf-8'));

    // Skip if already evaluated (check if evaluation.json is newer than session start)
    const evalFile = path.join(projectDir, '.orchestrator', 'evaluation.json');
    if (fs.existsSync(evalFile)) {
      try {
        const existingEval = JSON.parse(fs.readFileSync(evalFile, 'utf-8'));
        if (new Date(existingEval.evaluatedAt) > new Date(sessionData.startedAt)) {
          log('EVAL', `${projectName} already evaluated, skipping`);
          return;
        }
      } catch {}
    }

    log('EVAL', `Evaluating session for ${projectName}...`);
    const evaluation = await sessionEvaluator.evaluate({
      projectName: sessionData.projectName || projectName,
      projectDir,
      sessionName: sessionData.sessionName,
      startedAt: sessionData.startedAt,
      headBefore: sessionData.headBefore || null,
      prompt: sessionData.prompt || '',
    });

    log('EVAL', `${projectName}: score=${evaluation.score}/5, recommendation=${evaluation.recommendation}`);

    // Notify user if score is low (escalation)
    if (evaluation.score <= 2) {
      const msg = `Session ${projectName} scored ${evaluation.score}/5: ${evaluation.reasoning.substring(0, 200)}`;
      notificationManager.notify(msg, 2); // tier 2 = action needed
    }
  } catch (e) {
    log('EVAL', `Error evaluating ${projectName}: ${e.message}`);
  }
}
```

**Modify checkSessionTimeouts():**
After `sessionManager.stopSession(session.projectName)` succeeds (around line 231), trigger evaluation:
```javascript
// Trigger evaluation asynchronously (don't block timeout processing)
evaluateSession(session.projectName);
```
Note: evaluateSession is async but we intentionally don't await it -- timeout processing should not wait for LLM evaluation.

**Modify proactiveScan() ended session detection:**
In the section that checks for ended sessions (around line 187), after the ended session notification, trigger evaluation:
```javascript
if (session.ended && !lastSignalState[`${session.projectName}:ended`]) {
  // ... existing notification code ...
  // Trigger evaluation for ended session
  evaluateSession(session.projectName);
}
```

Do NOT:
- Await evaluateSession() in the timeout/scan loops (it uses semaphore, could block)
- Change the think cycle or message polling logic
- Modify the shutdown handler
- Remove any existing functionality
  </action>
  <verify>
`node -e "require('./index.js')" 2>&1 | head -20` -- should show the startup banner without crashes (it will start polling, so Ctrl-C after seeing banner).
Actually, better: `grep -n 'sessionEvaluator\|evaluateSession\|resourceMonitor\|gitTracker' index.js` -- should show all four names in imports, instantiation, and usage.
  </verify>
  <done>
SessionEvaluator is triggered after session timeout and natural session end. ResourceMonitor is wired into ContextAssembler. Evaluation results are logged, persisted, and surface in AI context.
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/context-assembler')"` loads without error
- `grep 'resourceMonitor' index.js` shows it wired to ContextAssembler
- `grep 'evaluateSession' index.js` shows evaluation triggers in checkSessionTimeouts and proactiveScan
- `grep '_buildResourceSection' lib/context-assembler.js` shows new section method
- `grep '_buildEvaluationSection' lib/context-assembler.js` shows new section method
- No new npm dependencies added
</verification>

<success_criteria>
The AI context prompt includes system resource data and recent evaluation summaries. Session evaluation is automatically triggered when sessions end (timeout or natural completion). Low-scoring sessions generate user notifications.
</success_criteria>

<output>
After completion, create `.planning/phases/04-session-intelligence/04-04-SUMMARY.md`
</output>
