---
phase: 06-revenue-and-autonomy
plan: 04
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - lib/scheduler.js
  - index.js
  - test/revenue-tracker.test.js
  - test/trust-tracker.test.js
  - test/helpers.js
autonomous: true

must_haves:
  truths:
    - "Scheduler has startEveningDigest(callback) method that schedules a cron job at 45 21 * * * in the configured timezone"
    - "Scheduler has startWeeklySummary(callback) method that schedules a cron job at 0 7 * * 0 (Sunday 7 AM) in the configured timezone"
    - "index.js has an eveningDigest function that generates an AI wind-down digest via claudePWithSemaphore with today's session accomplishments and commits"
    - "index.js has a weeklyRevenueSummary function that generates a revenue summary SMS with per-source breakdown and week-over-week trends"
    - "config.json has eveningDigest and weeklyRevenue sections with enabled flags and cron expressions"
    - "Revenue tracker tests verify SQLite schema creation, snapshot insertion with NULL vs zero, getLatest with data age, and formatForContext output"
    - "Trust tracker tests verify trust_summary table seeding, update accumulation, checkPromotion threshold logic, and no setAutonomyLevel calls"
    - "Running `node --test 'test/*.test.js'` passes all tests including new revenue-tracker and trust-tracker test files"
  artifacts:
    - path: "lib/scheduler.js"
      provides: "Evening digest and weekly summary scheduling"
      contains: "startEveningDigest"
    - path: "index.js"
      provides: "Evening digest and weekly summary generation and sending"
      contains: "eveningDigest"
    - path: "test/revenue-tracker.test.js"
      provides: "Tests for RevenueTracker module"
      contains: "describe.*RevenueTracker"
    - path: "test/trust-tracker.test.js"
      provides: "Tests for TrustTracker module"
      contains: "describe.*TrustTracker"
  key_links:
    - from: "lib/scheduler.js"
      to: "node-cron"
      via: "cron.schedule for evening and weekly jobs"
      pattern: "cron\\.schedule"
    - from: "index.js"
      to: "lib/scheduler.js"
      via: "scheduler.startEveningDigest and startWeeklySummary"
      pattern: "scheduler\\.startEveningDigest|scheduler\\.startWeeklySummary"
    - from: "test/revenue-tracker.test.js"
      to: "lib/revenue-tracker.js"
      via: "require and class instantiation with temp DB"
      pattern: "require.*revenue-tracker"
    - from: "test/trust-tracker.test.js"
      to: "lib/trust-tracker.js"
      via: "require and class instantiation with temp DB"
      pattern: "require.*trust-tracker"
---

<objective>
Add evening wind-down digest and weekly revenue summary as scheduled cron jobs, and create integration tests for the RevenueTracker and TrustTracker modules.

Purpose: The evening digest (REV-05) keeps the user informed about daily accomplishments without checking in during the evening. The weekly revenue summary (REV-04) provides a financial pulse check. Tests ensure the revenue and trust data layers are reliable.
Output: Updated scheduler.js, updated index.js, two new test files, updated config.json.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-revenue-and-autonomy/06-RESEARCH.md
@lib/scheduler.js
@lib/revenue-tracker.js
@lib/trust-tracker.js
@lib/ai-brain.js
@lib/exec.js
@lib/state.js
@lib/context-assembler.js
@lib/git-tracker.js
@config.json
@index.js
@test/helpers.js
@test/exec.test.js
@test/health-monitor.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add evening digest and weekly summary to scheduler.js</name>
  <files>lib/scheduler.js</files>
  <action>
Add two new scheduling methods to the Scheduler class, following the existing `startMorningDigest` pattern.

**startEveningDigest(callback):**
```javascript
startEveningDigest(callback) {
  const cronExpr = this.config.eveningDigest?.cron || '45 21 * * *';
  const tz = this.config.eveningDigest?.timezone || this.config.quietHours?.timezone || 'America/New_York';

  if (!this.config.eveningDigest?.enabled) return;

  const job = cron.schedule(
    cronExpr,
    () => {
      console.log(`[${new Date().toISOString()}] Sending evening digest...`);
      callback();
    },
    { timezone: tz }
  );

  this._jobs.push(job);
  console.log(`[SCHEDULER] Evening digest: ${cronExpr} (${tz})`);
}
```

**startWeeklySummary(callback):**
```javascript
startWeeklySummary(callback) {
  const cronExpr = this.config.weeklyRevenue?.cron || '0 7 * * 0';
  const tz = this.config.weeklyRevenue?.timezone || this.config.quietHours?.timezone || 'America/New_York';

  if (!this.config.weeklyRevenue?.enabled) return;

  const job = cron.schedule(
    cronExpr,
    () => {
      console.log(`[${new Date().toISOString()}] Sending weekly revenue summary...`);
      callback();
    },
    { timezone: tz }
  );

  this._jobs.push(job);
  console.log(`[SCHEDULER] Weekly revenue summary: ${cronExpr} (${tz})`);
}
```

Do NOT:
- Modify the existing startMorningDigest or isQuietTime methods
- Change the constructor signature
- Remove any existing functionality
  </action>
  <verify>
Run `node -e "const S = require('./lib/scheduler'); console.log(typeof S.prototype.startEveningDigest, typeof S.prototype.startWeeklySummary)"` -- should print two 'function' strings.
  </verify>
  <done>
Scheduler has startEveningDigest and startWeeklySummary methods that schedule cron jobs with configurable expressions and timezone.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add digest config and wiring in config.json and index.js</name>
  <files>config.json, index.js</files>
  <action>
**config.json:** Add `eveningDigest` and `weeklyRevenue` sections after the `trust` section:

```json
"eveningDigest": {
  "enabled": true,
  "cron": "45 21 * * *",
  "timezone": "America/New_York"
},
"weeklyRevenue": {
  "enabled": true,
  "cron": "0 7 * * 0",
  "timezone": "America/New_York"
}
```

**index.js:** Add the evening digest and weekly summary functions and wire them to the scheduler.

1. **Add evening digest function** after the existing `sendDigest` function:

```javascript
// -- Send evening wind-down digest -------------------------------------------
async function sendEveningDigest() {
  try {
    const { claudePWithSemaphore } = require('./lib/exec');

    // Gather today's data
    const stateData = state.load();
    const today = new Date().toISOString().split('T')[0];
    const todayExecs = (stateData.executionHistory || []).filter(e =>
      e.timestamp && e.timestamp.startsWith(today)
    );
    const todayEvals = (stateData.evaluationHistory || []).filter(e =>
      e.evaluatedAt && e.evaluatedAt.startsWith(today)
    );

    // Get commits across all projects today
    const commitSummaries = [];
    for (const projectName of CONFIG.projects) {
      try {
        const projectDir = path.join(CONFIG.projectsDir, projectName);
        const progress = gitTracker.getProgress(projectDir, 24);
        if (progress.commitCount > 0) {
          commitSummaries.push(`${projectName}: ${progress.commitCount} commits (+${progress.insertions}/-${progress.deletions})`);
        }
      } catch {}
    }

    const prompt = [
      'You are the AI brain of a project orchestrator. Generate a concise evening wind-down digest SMS (max 500 chars).',
      '',
      `Date: ${today}`,
      '',
      `Sessions today: ${todayExecs.filter(e => e.action === 'start').length} started`,
      `Evaluations today: ${todayEvals.length} (avg score: ${todayEvals.length > 0 ? (todayEvals.reduce((s, e) => s + (e.score || 0), 0) / todayEvals.length).toFixed(1) : 'N/A'})`,
      '',
      'Commits today:',
      commitSummaries.length > 0 ? commitSummaries.join('\n') : 'None',
      '',
      'Summarize the day\'s accomplishments and suggest what to focus on tomorrow. Be brief and actionable.',
    ].join('\n');

    const digest = await claudePWithSemaphore(prompt, { maxTurns: 1 });
    if (digest) {
      messenger.send(digest.substring(0, 1500));
      log('DIGEST', 'Sent evening wind-down digest');
    }
  } catch (e) {
    log('DIGEST', `Evening digest error: ${e.message}`);
  }
}
```

2. **Add weekly revenue summary function** after the evening digest function:

```javascript
// -- Send weekly revenue summary -----------------------------------------------
async function sendWeeklyRevenueSummary() {
  try {
    const trend = revenueTracker.getWeeklyTrend();
    const latest = revenueTracker.getLatest();

    const lines = ['Weekly Revenue Summary:'];
    lines.push('');

    // XMR Mining section
    lines.push('XMR Mining:');
    const xmr = latest['xmr-mining'];
    if (xmr && xmr.balance_atomic !== null) {
      const balXMR = (xmr.balance_atomic / 1e12).toFixed(6);
      const balUSD = xmr.xmr_price_usd ? (xmr.balance_atomic / 1e12 * xmr.xmr_price_usd).toFixed(2) : '?';
      lines.push(`  Balance: ${balXMR} XMR ($${balUSD})`);
      lines.push(`  Hashrate: ${xmr.hashrate || 0} H/s`);
    } else {
      lines.push('  No data available');
    }

    if (trend.thisWeek.xmr) {
      const tw = trend.thisWeek.xmr;
      lines.push(`  This week: ${tw.changeXMR >= 0 ? '+' : ''}${tw.changeXMR.toFixed(6)} XMR ($${tw.changeUSD.toFixed(2)})`);
      if (trend.lastWeek.xmr) {
        const lw = trend.lastWeek.xmr;
        const pctChange = lw.changeUSD !== 0
          ? Math.round((tw.changeUSD - lw.changeUSD) / Math.abs(lw.changeUSD) * 100)
          : null;
        lines.push(`  WoW: ${pctChange !== null ? (pctChange >= 0 ? '+' : '') + pctChange + '%' : 'N/A (first week)'}`);
      } else {
        lines.push('  WoW: N/A (first week)');
      }
    }

    lines.push('');

    // MLX API section
    lines.push('MLX API:');
    if (trend.thisWeek.mlx) {
      lines.push(`  Requests this week: ${trend.thisWeek.mlx.requests}`);
    } else {
      lines.push('  No data available');
    }
    lines.push('  Revenue: $0.00 (no active subscribers)');

    messenger.send(lines.join('\n'));
    log('REVENUE', 'Sent weekly revenue summary');
  } catch (e) {
    log('REVENUE', `Weekly summary error: ${e.message}`);
  }
}
```

3. **Wire to scheduler** -- after the existing `scheduler.startMorningDigest(sendDigest);` line:

```javascript
scheduler.startEveningDigest(sendEveningDigest);
scheduler.startWeeklySummary(sendWeeklyRevenueSummary);
```

Do NOT:
- Modify the existing morning digest function or its scheduling
- Remove any existing functionality from index.js
- Send the evening digest during quiet hours (the scheduler handles this)
  </action>
  <verify>
Run `node -e "const src = require('fs').readFileSync('./index.js','utf-8'); console.log(src.includes('sendEveningDigest'), src.includes('sendWeeklyRevenueSummary'), src.includes('startEveningDigest'), src.includes('startWeeklySummary'))"` -- should print four 'true' values.

Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.eveningDigest.enabled, c.weeklyRevenue.enabled)"` -- should print "true true".
  </verify>
  <done>
Evening digest (9:45 PM) and weekly revenue summary (Sunday 7 AM) are wired into the scheduler and index.js with AI-generated content for the evening digest and structured data for the weekly summary.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test/revenue-tracker.test.js</name>
  <files>test/revenue-tracker.test.js</files>
  <action>
Use `node:test` and `node:assert` (same pattern as existing tests). Import `{ describe, it, beforeEach, afterEach }` from `node:test` and `assert` from `node:assert/strict`.

Tests use a temp directory for SQLite DB isolation. Override the DB path by manipulating the module or by using a subclass that overrides _ensureDb.

**Approach for DB path isolation:** Create a test helper that sets up a RevenueTracker with a temp DB:

```javascript
const Database = require('better-sqlite3');
const path = require('path');
const os = require('os');
const fs = require('fs');

function createTestTracker(configOverrides = {}) {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'rt-test-'));
  const dbPath = path.join(tmpDir, 'test.db');
  const config = { revenue: { xmrWallet: 'test-wallet', retentionDays: 90, ...configOverrides } };
  const RT = require('../lib/revenue-tracker');
  const tracker = new RT({ config });

  // Override DB path for test isolation
  tracker._ensureDb = function() {
    if (this.db) return;
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS revenue_snapshots (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        source TEXT NOT NULL,
        collected_at TEXT NOT NULL,
        balance_atomic INTEGER,
        paid_atomic INTEGER,
        hashrate REAL,
        xmr_price_usd REAL,
        requests_served INTEGER,
        tokens_generated INTEGER,
        raw_json TEXT
      )
    `);
    this.db.exec(`CREATE INDEX IF NOT EXISTS idx_revenue_source_time ON revenue_snapshots(source, collected_at)`);
  };

  return { tracker, tmpDir, dbPath, cleanup: () => { tracker.close(); fs.rmSync(tmpDir, { recursive: true, force: true }); } };
}
```

**Test structure:**

```javascript
describe('RevenueTracker', () => {

  describe('schema', () => {
    it('creates revenue_snapshots table on first access');
    it('creates index on source + collected_at');
  });

  describe('snapshot storage', () => {
    it('stores XMR snapshot with all fields populated');
    it('stores MLX snapshot with requests and tokens');
    it('stores NULL fields when data is unavailable (not zero)');
    it('stores zero fields when data is genuinely zero');
    it('NULL and zero are distinguishable in queries');
  });

  describe('getLatest', () => {
    it('returns null for source with no snapshots');
    it('returns most recent snapshot per source');
    it('includes ageMinutes based on collected_at');
  });

  describe('formatForContext', () => {
    it('returns null when no data exists');
    it('includes XMR balance in USD with data age');
    it('includes MLX request count with data age');
    it('shows data unavailable for NULL snapshots');
    it('shows stale warning for old data');
  });

  describe('getWeeklyTrend', () => {
    it('returns null for weeks with no data');
    it('calculates XMR balance change over the week');
    it('calculates MLX request delta over the week');
  });

  describe('_maybePrune', () => {
    it('deletes snapshots older than retention period');
    it('keeps snapshots within retention period');
  });

  describe('close', () => {
    it('closes the database connection');
    it('is safe to call multiple times');
  });
});
```

**Key test implementations:**

For snapshot storage tests, directly insert rows using tracker.db.prepare().run() after calling tracker._ensureDb(), then verify with getLatest().

```javascript
it('stores NULL fields when data is unavailable', () => {
  const { tracker, cleanup } = createTestTracker();
  try {
    tracker._ensureDb();
    tracker.db.prepare(`
      INSERT INTO revenue_snapshots (source, collected_at, balance_atomic, paid_atomic, hashrate, xmr_price_usd)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run('xmr-mining', new Date().toISOString(), null, null, null, null);

    const latest = tracker.getLatest();
    assert.equal(latest['xmr-mining'].balance_atomic, null);
    assert.equal(latest['xmr-mining'].paid_atomic, null);
  } finally {
    cleanup();
  }
});

it('NULL and zero are distinguishable', () => {
  const { tracker, cleanup } = createTestTracker();
  try {
    tracker._ensureDb();
    // Insert a zero row
    tracker.db.prepare(`
      INSERT INTO revenue_snapshots (source, collected_at, balance_atomic)
      VALUES (?, ?, ?)
    `).run('xmr-mining', new Date().toISOString(), 0);

    const latest = tracker.getLatest();
    assert.equal(latest['xmr-mining'].balance_atomic, 0);
    assert.notEqual(latest['xmr-mining'].balance_atomic, null);
  } finally {
    cleanup();
  }
});
```

For formatForContext tests:
```javascript
it('returns null when no data exists', () => {
  const { tracker, cleanup } = createTestTracker();
  try {
    const result = tracker.formatForContext();
    assert.equal(result, null);
  } finally {
    cleanup();
  }
});

it('includes XMR balance in USD with data age', () => {
  const { tracker, cleanup } = createTestTracker();
  try {
    tracker._ensureDb();
    tracker.db.prepare(`
      INSERT INTO revenue_snapshots (source, collected_at, balance_atomic, paid_atomic, hashrate, xmr_price_usd)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run('xmr-mining', new Date().toISOString(), 629305994, 0, 2592, 330.0);

    const result = tracker.formatForContext();
    assert.ok(result.includes('Revenue:'));
    assert.ok(result.includes('XMR Mining'));
    assert.ok(result.includes('$'));
    assert.ok(result.includes('H/s'));
  } finally {
    cleanup();
  }
});
```

Do NOT:
- Make real HTTP requests to SupportXMR, CoinGecko, or MLX
- Use any test framework beyond node:test and node:assert
- Skip cleanup of temp directories
  </action>
  <verify>
`node --test test/revenue-tracker.test.js` passes all tests.
  </verify>
  <done>
RevenueTracker has comprehensive tests covering schema creation, NULL vs zero distinction, getLatest with data age, formatForContext output, weekly trends, pruning, and close behavior.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create test/trust-tracker.test.js</name>
  <files>test/trust-tracker.test.js</files>
  <action>
Use `node:test` and `node:assert` (same pattern as existing tests). Import `{ describe, it, beforeEach, afterEach }` from `node:test` and `assert` from `node:assert/strict`.

Tests use a temp directory for SQLite DB isolation, same approach as revenue-tracker tests.

**Test helper:**
```javascript
function createTestTracker(configOverrides = {}, stateOverrides = {}) {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'tt-test-'));
  const dbPath = path.join(tmpDir, 'test.db');

  const defaultState = {
    executionHistory: [],
    evaluationHistory: [],
    runtimeAutonomyLevel: 'cautious',
  };
  const stateData = { ...defaultState, ...stateOverrides };

  const mockState = {
    load: () => stateData,
    getAutonomyLevel: (s, c) => s.runtimeAutonomyLevel || c.ai?.autonomyLevel || 'observe',
  };

  const config = {
    ai: { autonomyLevel: 'observe' },
    trust: {
      enabled: true,
      thresholds: {
        cautious_to_moderate: { minSessions: 30, minAvgScore: 3.5, minDaysAtLevel: 7 },
        moderate_to_full: { minSessions: 50, minAvgScore: 4.0, minDaysAtLevel: 14 },
      },
      ...configOverrides,
    },
  };

  const TT = require('../lib/trust-tracker');
  const tracker = new TT({ config, state: mockState });

  // Override DB path
  tracker._ensureDb = function() {
    if (this.db) return;
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS trust_summary (
        autonomy_level TEXT PRIMARY KEY,
        total_sessions INTEGER DEFAULT 0,
        total_evaluations INTEGER DEFAULT 0,
        sum_eval_scores REAL DEFAULT 0,
        false_alerts INTEGER DEFAULT 0,
        true_alerts INTEGER DEFAULT 0,
        first_entered_at TEXT,
        last_entered_at TEXT,
        total_days REAL DEFAULT 0
      )
    `);
    const insert = this.db.prepare('INSERT OR IGNORE INTO trust_summary (autonomy_level) VALUES (?)');
    for (const level of ['observe', 'cautious', 'moderate', 'full']) {
      insert.run(level);
    }
  };

  return { tracker, tmpDir, mockState, stateData, cleanup: () => { tracker.close(); fs.rmSync(tmpDir, { recursive: true, force: true }); } };
}
```

**Test structure:**

```javascript
describe('TrustTracker', () => {

  describe('schema', () => {
    it('creates trust_summary table with 4 rows on first access');
    it('seeds all four autonomy levels');
  });

  describe('update', () => {
    it('increments total_sessions for new start executions');
    it('accumulates evaluation scores');
    it('only counts new entries since last update');
    it('handles empty execution and evaluation history');
  });

  describe('checkPromotion', () => {
    it('returns null for observe level (never automated)');
    it('returns null for full level (no higher level)');
    it('returns null when thresholds not met');
    it('returns recommendation string when all thresholds met');
    it('includes session count and avg score in recommendation');
    it('returns null on second call (already sent)');
    it('returns recommendation again after resetPromotionFlag');
  });

  describe('safety - no self-promotion', () => {
    it('source code does not contain setAutonomyLevel');
  });

  describe('getMetrics', () => {
    it('returns current level with zero metrics when new');
    it('returns accurate session count and avg score');
    it('includes promotion progress with percentages');
    it('returns null promotionProgress for full level');
  });

  describe('formatForContext', () => {
    it('includes current level and days');
    it('includes session count');
    it('includes avg eval score');
    it('includes promotion progress when applicable');
    it('shows N/A for eval score with zero evaluations');
  });

  describe('close', () => {
    it('closes the database connection');
    it('is safe to call multiple times');
  });
});
```

**Key test implementations:**

```javascript
it('returns null for observe level', () => {
  const { tracker, cleanup, stateData } = createTestTracker({}, { runtimeAutonomyLevel: 'observe' });
  try {
    const result = tracker.checkPromotion();
    assert.equal(result, null);
  } finally {
    cleanup();
  }
});

it('returns recommendation when all thresholds met', () => {
  const { tracker, cleanup } = createTestTracker({
    thresholds: {
      cautious_to_moderate: { minSessions: 2, minAvgScore: 3.0, minDaysAtLevel: 0 },
    },
  }, { runtimeAutonomyLevel: 'cautious' });
  try {
    tracker._ensureDb();
    // Seed metrics above thresholds
    tracker.db.prepare(`
      UPDATE trust_summary
      SET total_sessions = 5, total_evaluations = 3, sum_eval_scores = 12.0,
          last_entered_at = ?
      WHERE autonomy_level = 'cautious'
    `).run(new Date().toISOString());

    const result = tracker.checkPromotion();
    assert.ok(result !== null);
    assert.ok(result.includes('cautious'));
    assert.ok(result.includes('moderate'));
    assert.ok(result.includes('ai level moderate'));
  } finally {
    cleanup();
  }
});

it('returns null on second call (already sent)', () => {
  const { tracker, cleanup } = createTestTracker({
    thresholds: {
      cautious_to_moderate: { minSessions: 1, minAvgScore: 1.0, minDaysAtLevel: 0 },
    },
  }, { runtimeAutonomyLevel: 'cautious' });
  try {
    tracker._ensureDb();
    tracker.db.prepare(`
      UPDATE trust_summary
      SET total_sessions = 5, total_evaluations = 1, sum_eval_scores = 4.0,
          last_entered_at = ?
      WHERE autonomy_level = 'cautious'
    `).run(new Date().toISOString());

    const first = tracker.checkPromotion();
    assert.ok(first !== null);
    const second = tracker.checkPromotion();
    assert.equal(second, null);
  } finally {
    cleanup();
  }
});

it('source code does not contain setAutonomyLevel', () => {
  const src = fs.readFileSync(path.join(__dirname, '..', 'lib', 'trust-tracker.js'), 'utf-8');
  assert.equal(src.includes('setAutonomyLevel'), false, 'trust-tracker.js must never call setAutonomyLevel');
});
```

Do NOT:
- Make actual LLM calls in tests
- Use any test framework beyond node:test and node:assert
- Skip cleanup of temp directories
- Include setAutonomyLevel anywhere in the test expectations (only verify its absence)
  </action>
  <verify>
`node --test test/trust-tracker.test.js` passes all tests.
`node --test 'test/*.test.js'` passes ALL tests (existing + new).
  </verify>
  <done>
TrustTracker has comprehensive tests covering schema seeding, metric accumulation, promotion threshold logic, safety verification (no self-promotion), context formatting, and close behavior. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
- `node --test 'test/*.test.js'` passes ALL tests (existing + new, should be 11 files total)
- `node -e "require('./lib/scheduler')"` loads without error
- Scheduler has startEveningDigest and startWeeklySummary methods
- index.js has sendEveningDigest and sendWeeklyRevenueSummary functions
- config.json has eveningDigest and weeklyRevenue sections
- Revenue tracker tests verify NULL vs zero distinction
- Trust tracker tests verify no setAutonomyLevel calls exist
- No new npm dependencies added
</verification>

<success_criteria>
Evening digest fires at 9:45 PM with AI-generated content summarizing the day. Weekly revenue summary fires Sunday 7 AM with per-source breakdown and WoW trends. Both new modules have passing tests covering core logic and safety properties. All existing tests continue to pass.
</success_criteria>

<output>
After completion, create `.planning/phases/06-revenue-and-autonomy/06-04-SUMMARY.md`
</output>
