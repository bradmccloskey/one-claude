---
phase: 06-revenue-and-autonomy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/trust-tracker.js
  - config.json
autonomous: true

must_haves:
  truths:
    - "TrustTracker lazily initializes a trust_summary table in orchestrator.db with 4 rows (one per autonomy level)"
    - "trust_summary table has columns: autonomy_level (PK), total_sessions, total_evaluations, sum_eval_scores, false_alerts, true_alerts, first_entered_at, last_entered_at, total_days"
    - "update() reads executionHistory and evaluationHistory from state to accumulate trust metrics for the current autonomy level"
    - "update() increments total_sessions by counting new execution records with action='start' since last update"
    - "update() accumulates evaluation scores by adding new evaluations since last update to sum_eval_scores and total_evaluations"
    - "checkPromotion() compares current level metrics against configurable thresholds and returns a promotion recommendation or null"
    - "checkPromotion() returns null for observe level (observe->cautious is never automated)"
    - "checkPromotion() never calls state.setAutonomyLevel() -- it only returns a recommendation string"
    - "getMetrics() returns current level stats including sessions, avg score, days at level, and progress toward promotion"
    - "formatForContext() returns a compact string showing trust metrics and promotion progress"
    - "config.json has a trust section with promotion thresholds for cautious->moderate and moderate->full"
  artifacts:
    - path: "lib/trust-tracker.js"
      provides: "Trust metric accumulation and autonomy promotion recommendations"
      exports: ["TrustTracker"]
    - path: "config.json"
      provides: "Trust threshold configuration"
      contains: "trust"
  key_links:
    - from: "lib/trust-tracker.js"
      to: "better-sqlite3"
      via: "Database constructor for orchestrator.db (shared with revenue-tracker)"
      pattern: "require.*better-sqlite3"
    - from: "lib/trust-tracker.js"
      to: "lib/state.js"
      via: "state.load() for executionHistory and evaluationHistory"
      pattern: "this\\.state\\.load"
    - from: "lib/trust-tracker.js"
      to: "config.json"
      via: "this.config.trust for promotion thresholds"
      pattern: "this\\.config\\.trust"
---

<objective>
Create the TrustTracker module that accumulates per-autonomy-level trust metrics (sessions launched, avg evaluation score, days at level) from existing state data, checks promotion thresholds, and returns promotion recommendations via SMS -- without ever self-promoting.

Purpose: Trust is how the orchestrator earns higher autonomy. By tracking its track record per level, it can demonstrate competence and recommend promotion. The user always has the final say. This plan creates the tracker and threshold logic -- context integration is in 06-03, scheduling in 06-04.
Output: New lib/trust-tracker.js, updated config.json with trust thresholds.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-revenue-and-autonomy/06-RESEARCH.md
@lib/state.js
@lib/context-assembler.js
@lib/notification-manager.js
@config.json
@index.js
@test/helpers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/trust-tracker.js</name>
  <files>lib/trust-tracker.js</files>
  <action>
Create a TrustTracker class following the existing DI pattern.

**Constructor:**
```javascript
const Database = require('better-sqlite3');
const path = require('path');

class TrustTracker {
  constructor({ config, state }) {
    this.config = config;
    this.state = state;
    this.db = null; // Lazy init (shared orchestrator.db)
    this._lastUpdateTime = 0;
    this._lastSessionCount = 0;
    this._lastEvalCount = 0;
    this._promotionSent = false; // Tracks if a promotion SMS was already sent at current level
  }
}
```

**_ensureDb()** -- lazy SQLite initialization. Uses the SAME orchestrator.db as RevenueTracker:
```javascript
_ensureDb() {
  if (this.db) return;
  const dbPath = path.join(__dirname, '..', 'orchestrator.db');
  this.db = new Database(dbPath);
  this.db.pragma('journal_mode = WAL');
  this.db.exec(`
    CREATE TABLE IF NOT EXISTS trust_summary (
      autonomy_level TEXT PRIMARY KEY,
      total_sessions INTEGER DEFAULT 0,
      total_evaluations INTEGER DEFAULT 0,
      sum_eval_scores REAL DEFAULT 0,
      false_alerts INTEGER DEFAULT 0,
      true_alerts INTEGER DEFAULT 0,
      first_entered_at TEXT,
      last_entered_at TEXT,
      total_days REAL DEFAULT 0
    )
  `);

  // Seed rows for all 4 levels if they don't exist
  const insert = this.db.prepare(`
    INSERT OR IGNORE INTO trust_summary (autonomy_level) VALUES (?)
  `);
  for (const level of ['observe', 'cautious', 'moderate', 'full']) {
    insert.run(level);
  }
}
```

**update()** -- called periodically to accumulate trust metrics from state. Reads executionHistory and evaluationHistory, counts new entries since last update, and updates the trust_summary row for the current autonomy level.

```javascript
update() {
  this._ensureDb();
  const stateData = this.state.load();
  const currentLevel = this.state.getAutonomyLevel(stateData, this.config);

  // Ensure this level has an entered_at timestamp
  const row = this.db.prepare(
    'SELECT * FROM trust_summary WHERE autonomy_level = ?'
  ).get(currentLevel);

  if (!row.last_entered_at) {
    this.db.prepare(
      'UPDATE trust_summary SET first_entered_at = ?, last_entered_at = ? WHERE autonomy_level = ?'
    ).run(new Date().toISOString(), new Date().toISOString(), currentLevel);
  }

  // Count new sessions (action='start' in executionHistory)
  const execHistory = stateData.executionHistory || [];
  const currentSessionCount = execHistory.filter(e => e.action === 'start').length;
  const newSessions = Math.max(0, currentSessionCount - this._lastSessionCount);
  this._lastSessionCount = currentSessionCount;

  // Count new evaluations
  const evalHistory = stateData.evaluationHistory || [];
  const currentEvalCount = evalHistory.length;
  const newEvals = Math.max(0, currentEvalCount - this._lastEvalCount);
  this._lastEvalCount = currentEvalCount;

  if (newSessions > 0 || newEvals > 0) {
    // Sum scores of new evaluations
    const newEvalScores = evalHistory.slice(-newEvals).reduce((sum, e) => sum + (e.score || 0), 0);

    this.db.prepare(`
      UPDATE trust_summary
      SET total_sessions = total_sessions + ?,
          total_evaluations = total_evaluations + ?,
          sum_eval_scores = sum_eval_scores + ?
      WHERE autonomy_level = ?
    `).run(newSessions, newEvals, newEvalScores, currentLevel);
  }

  this._lastUpdateTime = Date.now();
}
```

**checkPromotion()** -- compares current level metrics against thresholds. Returns a recommendation string or null. NEVER self-promotes.

```javascript
checkPromotion() {
  this._ensureDb();
  const stateData = this.state.load();
  const currentLevel = this.state.getAutonomyLevel(stateData, this.config);

  // observe -> cautious is a policy decision, not automated
  if (currentLevel === 'observe') return null;
  // full has no higher level
  if (currentLevel === 'full') return null;
  // Already sent a promotion recommendation at this level
  if (this._promotionSent) return null;

  const nextLevel = currentLevel === 'cautious' ? 'moderate' : 'full';
  const thresholdKey = `${currentLevel}_to_${nextLevel}`;
  const thresholds = this.config.trust?.thresholds?.[thresholdKey];
  if (!thresholds) return null;

  const row = this.db.prepare(
    'SELECT * FROM trust_summary WHERE autonomy_level = ?'
  ).get(currentLevel);

  if (!row) return null;

  const avgScore = row.total_evaluations > 0
    ? row.sum_eval_scores / row.total_evaluations
    : 0;

  const daysAtLevel = row.last_entered_at
    ? (Date.now() - new Date(row.last_entered_at).getTime()) / 86400000 + (row.total_days || 0)
    : 0;

  // Check all thresholds
  const meetsSession = row.total_sessions >= (thresholds.minSessions || 30);
  const meetsScore = avgScore >= (thresholds.minAvgScore || 3.5);
  const meetsDays = daysAtLevel >= (thresholds.minDaysAtLevel || 7);

  if (meetsSession && meetsScore && meetsDays) {
    this._promotionSent = true;
    return `Trust metrics suggest promotion from ${currentLevel} to ${nextLevel}. ` +
      `${row.total_sessions} sessions, avg score ${avgScore.toFixed(1)}/5, ` +
      `${Math.round(daysAtLevel)} days at level. ` +
      `Send \`ai level ${nextLevel}\` to approve.`;
  }

  return null;
}
```

**resetPromotionFlag()** -- called when autonomy level changes so new level can eventually trigger its own promotion check:
```javascript
resetPromotionFlag() {
  this._promotionSent = false;
}
```

**getMetrics()** -- returns current level stats for context and API:
```javascript
getMetrics() {
  this._ensureDb();
  const stateData = this.state.load();
  const currentLevel = this.state.getAutonomyLevel(stateData, this.config);

  const row = this.db.prepare(
    'SELECT * FROM trust_summary WHERE autonomy_level = ?'
  ).get(currentLevel);

  if (!row) return { level: currentLevel, sessions: 0, avgScore: 0, days: 0 };

  const avgScore = row.total_evaluations > 0
    ? row.sum_eval_scores / row.total_evaluations
    : 0;

  const daysAtLevel = row.last_entered_at
    ? (Date.now() - new Date(row.last_entered_at).getTime()) / 86400000 + (row.total_days || 0)
    : 0;

  // Calculate promotion progress
  const nextLevel = currentLevel === 'cautious' ? 'moderate'
    : currentLevel === 'moderate' ? 'full' : null;
  const thresholdKey = nextLevel ? `${currentLevel}_to_${nextLevel}` : null;
  const thresholds = thresholdKey ? this.config.trust?.thresholds?.[thresholdKey] : null;

  let promotionProgress = null;
  if (thresholds) {
    const sessionPct = Math.min(100, Math.round(row.total_sessions / (thresholds.minSessions || 30) * 100));
    const scoreMet = avgScore >= (thresholds.minAvgScore || 3.5);
    const daysPct = Math.min(100, Math.round(daysAtLevel / (thresholds.minDaysAtLevel || 7) * 100));
    promotionProgress = { sessionPct, scoreMet, daysPct, nextLevel };
  }

  return {
    level: currentLevel,
    sessions: row.total_sessions,
    evaluations: row.total_evaluations,
    avgScore: parseFloat(avgScore.toFixed(2)),
    days: parseFloat(daysAtLevel.toFixed(1)),
    promotionProgress,
  };
}
```

**formatForContext()** -- compact string for AI context:
```javascript
formatForContext() {
  const metrics = this.getMetrics();
  const lines = ['Trust Metrics:'];
  lines.push(`- Current level: ${metrics.level} (${metrics.days} days)`);
  lines.push(`- Sessions at this level: ${metrics.sessions}`);

  if (metrics.evaluations > 0) {
    lines.push(`- Avg eval score: ${metrics.avgScore}/5.0 (${metrics.evaluations} evaluations)`);
  } else {
    lines.push('- Avg eval score: N/A (no evaluations yet)');
  }

  if (metrics.promotionProgress) {
    const p = metrics.promotionProgress;
    lines.push(`- Promotion to ${p.nextLevel}: sessions ${p.sessionPct}%, score ${p.scoreMet ? 'MET' : 'NOT MET'}, days ${p.daysPct}%`);
  }

  return lines.join('\n');
}
```

**close()** -- for graceful shutdown:
```javascript
close() {
  if (this.db) {
    this.db.close();
    this.db = null;
  }
}
```

Export: `module.exports = TrustTracker;`

Do NOT:
- Call state.setAutonomyLevel() from anywhere in this module (critical safety property)
- Add any npm dependencies
- Store trust metrics in .state.json (SQLite only)
- Automate the observe->cautious transition (that is a user policy decision)
- Send SMS directly -- return the recommendation string for the caller to send
  </action>
  <verify>
Run `node -e "const TT = require('./lib/trust-tracker'); console.log(typeof TT)"` -- should print 'function'.

Run `node -e "const TT = require('./lib/trust-tracker'); const s = { load: () => ({ executionHistory: [], evaluationHistory: [], runtimeAutonomyLevel: 'observe' }), getAutonomyLevel: () => 'observe' }; const tt = new TT({ config: {}, state: s }); console.log(typeof tt.update, typeof tt.checkPromotion, typeof tt.formatForContext, typeof tt.getMetrics)"` -- should print four 'function' strings.

Verify no self-promotion: `node -e "const src = require('fs').readFileSync('./lib/trust-tracker.js','utf-8'); console.log(!src.includes('setAutonomyLevel'))"` -- should print 'true'.
  </verify>
  <done>
TrustTracker class loads and exposes update(), checkPromotion(), formatForContext(), getMetrics(), close(). SQLite trust_summary table created with 4 level rows. No code path calls setAutonomyLevel -- promotion is recommendation-only.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add trust thresholds to config.json</name>
  <files>config.json</files>
  <action>
Add a `trust` key after the `revenue` section in config.json:

```json
"trust": {
  "enabled": true,
  "thresholds": {
    "cautious_to_moderate": {
      "minSessions": 30,
      "minAvgScore": 3.5,
      "minDaysAtLevel": 7
    },
    "moderate_to_full": {
      "minSessions": 50,
      "minAvgScore": 4.0,
      "minDaysAtLevel": 14
    }
  },
  "promotionCheckCron": "0 10 * * *"
}
```

Field explanations:
- `enabled`: master switch for trust tracking
- `thresholds`: per-transition thresholds. Each requires min sessions launched at that level, min average evaluation score, and min days at level.
- `promotionCheckCron`: daily at 10 AM for promotion threshold checking (used by 06-04)

Do NOT modify any existing config keys.
  </action>
  <verify>
Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.trust.enabled, c.trust.thresholds.cautious_to_moderate.minSessions, c.trust.thresholds.moderate_to_full.minAvgScore)"` -- should print "true 30 4".
  </verify>
  <done>
config.json has trust section with promotion thresholds for cautious->moderate (30 sessions, 3.5 score, 7 days) and moderate->full (50 sessions, 4.0 score, 14 days).
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/trust-tracker')"` loads without error
- `node -e "JSON.parse(require('fs').readFileSync('./config.json','utf-8')).trust.enabled === true"` returns true
- TrustTracker initializes SQLite table and seeds 4 autonomy level rows
- checkPromotion() returns null for observe level (never automated)
- checkPromotion() returns null for full level (no higher level)
- No code in trust-tracker.js calls setAutonomyLevel
- No new npm dependencies added
</verification>

<success_criteria>
TrustTracker exists with SQLite persistence, per-level trust metric accumulation, configurable promotion thresholds, and recommendation-only promotion checking. Config.json has trust thresholds. The orchestrator never self-promotes -- it recommends and waits for the user to send `ai level <level>`.
</success_criteria>

<output>
After completion, create `.planning/phases/06-revenue-and-autonomy/06-02-SUMMARY.md`
</output>
