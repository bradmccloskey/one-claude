---
phase: 06-revenue-and-autonomy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/revenue-tracker.js
  - .gitignore
  - config.json
autonomous: true

must_haves:
  truths:
    - "RevenueTracker lazily initializes a SQLite database at orchestrator.db with revenue_snapshots table on first access"
    - "revenue_snapshots table has columns: id, source, collected_at, balance_atomic, paid_atomic, hashrate, xmr_price_usd, requests_served, tokens_generated, raw_json"
    - "collect() fetches XMR pool stats from SupportXMR API and XMR price from CoinGecko, storing a single snapshot row with source='xmr-mining'"
    - "collect() fetches MLX /health endpoint, storing a snapshot row with source='mlx-api' and requests_served/tokens_generated"
    - "When an API fetch fails, NULL is stored for that source's data fields (not zero) -- NULL means no data, zero means genuinely zero"
    - "getLatest() returns the most recent successful snapshot per source with data age in minutes"
    - "formatForContext() returns a compact multi-line string showing per-source revenue data with data age"
    - "getWeeklyTrend() returns this week vs last week revenue data for week-over-week comparison"
    - "orchestrator.db is added to .gitignore"
    - "config.json has a revenue section with collection interval, XMR wallet address, and data retention settings"
  artifacts:
    - path: "lib/revenue-tracker.js"
      provides: "Revenue data collection from XMR mining and MLX API with SQLite persistence"
      exports: ["RevenueTracker"]
    - path: "config.json"
      provides: "Revenue configuration"
      contains: "revenue"
    - path: ".gitignore"
      provides: "Git ignore rules"
      contains: "orchestrator.db"
  key_links:
    - from: "lib/revenue-tracker.js"
      to: "better-sqlite3"
      via: "Database constructor for orchestrator.db"
      pattern: "require.*better-sqlite3"
    - from: "lib/revenue-tracker.js"
      to: "native fetch"
      via: "HTTP GET to SupportXMR, CoinGecko, and localhost:8100"
      pattern: "fetch\\("
    - from: "lib/revenue-tracker.js"
      to: "config.json"
      via: "this.config.revenue for wallet, intervals, retention"
      pattern: "this\\.config\\.revenue"
---

<objective>
Create the RevenueTracker module that collects earnings data from XMR mining (SupportXMR pool API + CoinGecko price) and MLX API usage metrics (/health endpoint), stores snapshots in a SQLite database with NULL vs zero distinction, and provides query methods for context assembly and weekly summaries.

Purpose: This is the data foundation for all revenue awareness. The orchestrator needs to know what projects earn money so it can make informed priority decisions. This plan creates the collector and storage -- context integration and digest formatting are in 06-03 and 06-04.
Output: New lib/revenue-tracker.js, updated config.json with revenue section, updated .gitignore with orchestrator.db.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-revenue-and-autonomy/06-RESEARCH.md
@lib/state.js
@lib/context-assembler.js
@lib/health-monitor.js
@config.json
@index.js
@test/helpers.js
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/revenue-tracker.js</name>
  <files>lib/revenue-tracker.js</files>
  <action>
Create a RevenueTracker class following the existing DI pattern.

**Constructor:**
```javascript
const Database = require('better-sqlite3');
const path = require('path');

class RevenueTracker {
  constructor({ config }) {
    this.config = config;
    this.db = null; // Lazy init
    this._lastCollectionTime = 0;
  }
}
```

**_ensureDb()** -- lazy SQLite initialization with WAL mode:
```javascript
_ensureDb() {
  if (this.db) return;
  const dbPath = path.join(__dirname, '..', 'orchestrator.db');
  this.db = new Database(dbPath);
  this.db.pragma('journal_mode = WAL');
  this.db.exec(`
    CREATE TABLE IF NOT EXISTS revenue_snapshots (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      source TEXT NOT NULL,
      collected_at TEXT NOT NULL,
      balance_atomic INTEGER,
      paid_atomic INTEGER,
      hashrate REAL,
      xmr_price_usd REAL,
      requests_served INTEGER,
      tokens_generated INTEGER,
      raw_json TEXT
    )
  `);
  this.db.exec(`
    CREATE INDEX IF NOT EXISTS idx_revenue_source_time
    ON revenue_snapshots(source, collected_at)
  `);
}
```

**async collect()** -- main entry point, called from the scan loop. Fetches data from all sources independently. One source failure must NOT block another.

```javascript
async collect() {
  this._ensureDb();
  const now = new Date().toISOString();

  // Collect from each source independently
  await Promise.allSettled([
    this._collectXMR(now),
    this._collectMLX(now),
  ]);

  this._lastCollectionTime = Date.now();

  // Prune old data periodically (every 24 hours worth of collections)
  this._maybePrune();
}
```

**async _collectXMR(collectedAt)** -- fetch XMR pool stats and price:
```javascript
async _collectXMR(collectedAt) {
  const wallet = this.config.revenue?.xmrWallet;
  if (!wallet) return;

  let poolData = null;
  let priceData = null;

  // Fetch pool stats
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    const response = await fetch(
      `https://www.supportxmr.com/api/miner/${wallet}/stats`,
      { signal: controller.signal }
    );
    clearTimeout(timeoutId);
    if (response.ok) {
      poolData = await response.json();
    }
  } catch {}

  // Fetch XMR price
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    const response = await fetch(
      'https://api.coingecko.com/api/v3/simple/price?ids=monero&vs_currencies=usd',
      { signal: controller.signal }
    );
    clearTimeout(timeoutId);
    if (response.ok) {
      priceData = await response.json();
    }
  } catch {}

  // Store snapshot -- NULL for fields we couldn't fetch
  const stmt = this.db.prepare(`
    INSERT INTO revenue_snapshots
      (source, collected_at, balance_atomic, paid_atomic, hashrate, xmr_price_usd, raw_json)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `);

  stmt.run(
    'xmr-mining',
    collectedAt,
    poolData?.amtDue ?? null,
    poolData?.amtPaid ?? null,
    poolData?.hash ?? null,
    priceData?.monero?.usd ?? null,
    poolData ? JSON.stringify(poolData) : null,
  );
}
```

**async _collectMLX(collectedAt)** -- fetch MLX /health endpoint:
```javascript
async _collectMLX(collectedAt) {
  let healthData = null;

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    const response = await fetch('http://localhost:8100/health', {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);
    if (response.ok) {
      healthData = await response.json();
    }
  } catch {}

  const stmt = this.db.prepare(`
    INSERT INTO revenue_snapshots
      (source, collected_at, requests_served, tokens_generated, raw_json)
    VALUES (?, ?, ?, ?, ?)
  `);

  stmt.run(
    'mlx-api',
    collectedAt,
    healthData?.requests_served ?? null,
    healthData?.total_tokens_generated ?? null,
    healthData ? JSON.stringify(healthData) : null,
  );
}
```

**getLatest()** -- returns the most recent successful snapshot per source with data age:
```javascript
getLatest() {
  this._ensureDb();
  const result = {};

  for (const source of ['xmr-mining', 'mlx-api']) {
    const row = this.db.prepare(`
      SELECT * FROM revenue_snapshots
      WHERE source = ?
      ORDER BY collected_at DESC
      LIMIT 1
    `).get(source);

    if (row) {
      const ageMs = Date.now() - new Date(row.collected_at).getTime();
      const ageMinutes = Math.round(ageMs / 60000);
      result[source] = { ...row, ageMinutes };
    } else {
      result[source] = null;
    }
  }

  return result;
}
```

**formatForContext()** -- compact string for AI context with data age and stale warnings:
```javascript
formatForContext() {
  const latest = this.getLatest();
  if (!latest['xmr-mining'] && !latest['mlx-api']) return null;

  const lines = ['Revenue:'];

  // XMR Mining
  const xmr = latest['xmr-mining'];
  if (xmr && xmr.balance_atomic !== null) {
    const balanceXMR = xmr.balance_atomic / 1e12;
    const balanceUSD = xmr.xmr_price_usd ? (balanceXMR * xmr.xmr_price_usd).toFixed(2) : '?';
    const totalXMR = ((xmr.balance_atomic + (xmr.paid_atomic || 0)) / 1e12).toFixed(6);
    const ageStr = this._formatAge(xmr.ageMinutes);
    lines.push(`- XMR Mining: $${balanceUSD} balance (${balanceXMR.toFixed(6)} XMR), hashrate ${xmr.hashrate || 0} H/s (${ageStr})`);
  } else if (xmr) {
    lines.push(`- XMR Mining: data unavailable (${this._formatAge(xmr.ageMinutes)})`);
  } else {
    lines.push('- XMR Mining: no data collected yet');
  }

  // MLX API
  const mlx = latest['mlx-api'];
  if (mlx && mlx.requests_served !== null) {
    const ageStr = this._formatAge(mlx.ageMinutes);
    lines.push(`- MLX API: ${mlx.requests_served} requests served, ${mlx.tokens_generated || 0} tokens (${ageStr})`);
  } else if (mlx) {
    lines.push(`- MLX API: data unavailable (${this._formatAge(mlx.ageMinutes)})`);
  } else {
    lines.push('- MLX API: no data collected yet');
  }

  return lines.join('\n');
}

_formatAge(ageMinutes) {
  if (ageMinutes > 60) {
    const hours = Math.round(ageMinutes / 60);
    return hours > 1 ? `STALE: ${hours}h ago` : `${ageMinutes}min ago`;
  }
  return `${ageMinutes}min ago`;
}
```

**getWeeklyTrend()** -- returns this week vs last week data for WoW comparison:
```javascript
getWeeklyTrend() {
  this._ensureDb();

  const now = new Date();
  const thisWeekStart = new Date(now);
  thisWeekStart.setDate(now.getDate() - now.getDay()); // Start of this week (Sunday)
  thisWeekStart.setHours(0, 0, 0, 0);

  const lastWeekStart = new Date(thisWeekStart);
  lastWeekStart.setDate(lastWeekStart.getDate() - 7);

  const thisWeekISO = thisWeekStart.toISOString();
  const lastWeekISO = lastWeekStart.toISOString();
  const nowISO = now.toISOString();

  // Get XMR balance change this week (latest balance - earliest balance of the week)
  const getXMRChange = (startISO, endISO) => {
    const earliest = this.db.prepare(`
      SELECT balance_atomic, xmr_price_usd FROM revenue_snapshots
      WHERE source = 'xmr-mining' AND collected_at >= ? AND collected_at < ?
        AND balance_atomic IS NOT NULL
      ORDER BY collected_at ASC LIMIT 1
    `).get(startISO, endISO);

    const latest = this.db.prepare(`
      SELECT balance_atomic, paid_atomic, xmr_price_usd FROM revenue_snapshots
      WHERE source = 'xmr-mining' AND collected_at >= ? AND collected_at < ?
        AND balance_atomic IS NOT NULL
      ORDER BY collected_at DESC LIMIT 1
    `).get(startISO, endISO);

    if (!earliest || !latest) return null;

    // Total earned = (latest balance + latest paid) - (earliest balance + earliest paid_at_start)
    // Simplified: use balance delta (ignoring payouts within the week for now)
    const price = latest.xmr_price_usd || 0;
    const balanceChangeAtomic = latest.balance_atomic - earliest.balance_atomic + ((latest.paid_atomic || 0) - 0);
    const changeXMR = balanceChangeAtomic / 1e12;
    return { changeXMR, changeUSD: changeXMR * price, price };
  };

  // Get MLX request count for period
  const getMLXRequests = (startISO, endISO) => {
    const earliest = this.db.prepare(`
      SELECT requests_served FROM revenue_snapshots
      WHERE source = 'mlx-api' AND collected_at >= ? AND collected_at < ?
        AND requests_served IS NOT NULL
      ORDER BY collected_at ASC LIMIT 1
    `).get(startISO, endISO);

    const latest = this.db.prepare(`
      SELECT requests_served FROM revenue_snapshots
      WHERE source = 'mlx-api' AND collected_at >= ? AND collected_at < ?
        AND requests_served IS NOT NULL
      ORDER BY collected_at DESC LIMIT 1
    `).get(startISO, endISO);

    if (!earliest || !latest) return null;
    // Handle counter resets (service restarts)
    const delta = latest.requests_served - earliest.requests_served;
    return { requests: delta >= 0 ? delta : latest.requests_served };
  };

  return {
    thisWeek: {
      xmr: getXMRChange(thisWeekISO, nowISO),
      mlx: getMLXRequests(thisWeekISO, nowISO),
    },
    lastWeek: {
      xmr: getXMRChange(lastWeekISO, thisWeekISO),
      mlx: getMLXRequests(lastWeekISO, thisWeekISO),
    },
  };
}
```

**_maybePrune()** -- delete snapshots older than retention period:
```javascript
_maybePrune() {
  const retentionDays = this.config.revenue?.retentionDays || 90;
  // Only prune once per day
  if (!this._lastPruneTime || Date.now() - this._lastPruneTime > 86400000) {
    const cutoff = new Date(Date.now() - retentionDays * 86400000).toISOString();
    this.db.prepare('DELETE FROM revenue_snapshots WHERE collected_at < ?').run(cutoff);
    this._lastPruneTime = Date.now();
  }
}
```

**close()** -- for graceful shutdown:
```javascript
close() {
  if (this.db) {
    this.db.close();
    this.db = null;
  }
}
```

Export: `module.exports = RevenueTracker;`

Do NOT:
- Add any npm dependencies (use native fetch and existing better-sqlite3)
- Store revenue data in .state.json (SQLite only)
- Make MLX revenue non-null until RapidAPI subscriptions are confirmed (requests_served is a usage metric, not revenue)
- Throw from collect() -- all errors are caught per source
  </action>
  <verify>
Run `node -e "const RT = require('./lib/revenue-tracker'); console.log(typeof RT)"` -- should print 'function'.

Run `node -e "const RT = require('./lib/revenue-tracker'); const rt = new RT({ config: { revenue: {} } }); console.log(typeof rt.collect, typeof rt.getLatest, typeof rt.formatForContext, typeof rt.getWeeklyTrend)"` -- should print four 'function' strings.

Run `node -e "const RT = require('./lib/revenue-tracker'); const rt = new RT({ config: { revenue: {} } }); rt._ensureDb(); console.log(rt.db !== null)"` -- should print 'true'.
  </verify>
  <done>
RevenueTracker class loads and exposes collect(), getLatest(), formatForContext(), getWeeklyTrend(), close(). SQLite schema created with NULL vs zero distinction. XMR and MLX collection implemented independently.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update config.json and .gitignore</name>
  <files>config.json, .gitignore</files>
  <action>
**config.json:** Add a `revenue` key after the `health` section:

```json
"revenue": {
  "enabled": true,
  "collectionIntervalScans": 5,
  "xmrWallet": "45c7vD9rqJyBRX6CMHp4kJAUcB8zZBmKQTkX6KHLcJeXaiDLoLW6NzXYjwHbkWwJuo6zmcoVKTrtAfnVNnyHMgm3P7a4LQD",
  "retentionDays": 90
}
```

Field explanations:
- `enabled`: master switch for revenue collection
- `collectionIntervalScans`: collect every N scan cycles (5 * 60s = 5 minutes)
- `xmrWallet`: SupportXMR wallet address for API calls
- `retentionDays`: how long to keep snapshots (90 days = ~26K rows max)

**Do NOT** modify any existing config keys.

**.gitignore:** Add `orchestrator.db` on its own line after the existing entries.

Do NOT remove any existing gitignore entries.
  </action>
  <verify>
Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.revenue.enabled, c.revenue.collectionIntervalScans, c.revenue.xmrWallet.substring(0,10))"` -- should print "true 5 45c7vD9rqJ".

Run `node -e "console.log(require('fs').readFileSync('./.gitignore','utf-8').includes('orchestrator.db'))"` -- should print "true".
  </verify>
  <done>
config.json has revenue section with wallet, interval, and retention config. .gitignore excludes orchestrator.db.
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/revenue-tracker')"` loads without error
- `node -e "JSON.parse(require('fs').readFileSync('./config.json','utf-8')).revenue.enabled === true"` returns true
- `.gitignore` contains `orchestrator.db`
- RevenueTracker can initialize the SQLite DB, insert a snapshot, and query it back
- collect() does not throw even when APIs are unreachable (stores NULLs)
- No new npm dependencies added
</verification>

<success_criteria>
RevenueTracker exists with SQLite persistence, XMR and MLX data collection, NULL vs zero distinction, data age tracking, and weekly trend queries. Config.json has revenue settings. The orchestrator.db file is git-ignored. No context wiring yet -- that is 06-03.
</success_criteria>

<output>
After completion, create `.planning/phases/06-revenue-and-autonomy/06-01-SUMMARY.md`
</output>
