---
phase: 05-infrastructure-monitoring
plan: 04
type: execute
wave: 3
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - test/health-monitor.test.js
  - test/mcp-bridge.test.js
  - test/helpers.js
autonomous: true

must_haves:
  truths:
    - "Running `node --test 'test/*.test.js'` passes all tests including the new health-monitor and mcp-bridge test files"
    - "Health monitor tests verify HTTP checks (mock fetch), process checks (mock execSync), Docker checks (mock execSync), and consecutive failure tracking"
    - "Health monitor tests verify correlated failure detection blocks restarts when 3+ services are down"
    - "Health monitor tests verify restart budget enforcement (max 2/hr sliding window)"
    - "Health monitor tests verify autonomy gating (observe/cautious = no restart, moderate/full = restart allowed)"
    - "MCP bridge tests verify circuit breaker state transitions (closed -> open -> half-open -> closed)"
    - "MCP bridge tests verify queryMCP rejects immediately when circuit breaker is open"
    - "Test helpers include mocks for healthMonitor and mcpBridge"
  artifacts:
    - path: "test/health-monitor.test.js"
      provides: "Tests for HealthMonitor module"
      contains: "describe.*HealthMonitor"
    - path: "test/mcp-bridge.test.js"
      provides: "Tests for MCPBridge and CircuitBreaker"
      contains: "describe.*CircuitBreaker"
    - path: "test/helpers.js"
      provides: "Updated mock deps with healthMonitor and mcpBridge"
      contains: "healthMonitor"
  key_links:
    - from: "test/health-monitor.test.js"
      to: "lib/health-monitor.js"
      via: "require and class instantiation with mocked deps"
      pattern: "require.*health-monitor"
    - from: "test/mcp-bridge.test.js"
      to: "lib/mcp-bridge.js"
      via: "require and class instantiation"
      pattern: "require.*mcp-bridge"
---

<objective>
Add integration tests for the two new Phase 05 modules (HealthMonitor and MCPBridge/CircuitBreaker), following the established node:test patterns. Update test helpers with mocks for new modules.

Purpose: Tests verify the health monitoring and MCP bridge work correctly, covering safety-critical paths like restart budget enforcement, correlated failure detection, autonomy gating, and circuit breaker state transitions.
Output: Two new test files and updated test/helpers.js.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/health-monitor.js
@lib/mcp-bridge.js
@lib/exec.js
@lib/state.js
@lib/notification-manager.js
@test/helpers.js
@test/exec.test.js
@test/session-evaluator.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test/health-monitor.test.js</name>
  <files>test/health-monitor.test.js</files>
  <action>
Use `node:test` and `node:assert` (same pattern as existing tests). Import `{ describe, it, beforeEach, afterEach, mock }` from `node:test` and `assert` from `node:assert/strict`.

The HealthMonitor uses `fetch` (global) and `execSync` (from child_process). Tests should avoid real network calls and shell commands where possible. For unit testing the check logic, construct HealthMonitor with mock deps and test the internal methods.

**Test structure:**

```javascript
describe('HealthMonitor', () => {

  describe('constructor', () => {
    it('initializes with config services');
    it('defaults to enabled when health.enabled is not set');
    it('handles missing health config gracefully');
  });

  describe('_checkHTTP', () => {
    // Test HTTP checks by temporarily replacing global fetch
    it('returns up when fetch succeeds with 200');
    it('returns up when fetch succeeds with 404 (any HTTP response = alive)');
    it('returns down when fetch throws ECONNREFUSED');
    it('returns down when fetch times out');
  });

  describe('_checkProcess', () => {
    // Test process checks by patching child_process
    it('returns up with PID when launchctl shows running service');
    it('returns down when launchctl shows no PID');
    it('returns down when launchctl throws');
  });

  describe('_checkDocker', () => {
    it('returns up when all containers are running');
    it('returns down with list of stopped containers');
    it('returns down when docker command fails');
  });

  describe('consecutive failure tracking', () => {
    it('increments consecutiveFails on each failure');
    it('resets consecutiveFails to 0 on success');
  });

  describe('_processResults - alert routing', () => {
    it('sends URGENT notification after consecutiveFailsBeforeAlert failures');
    it('does not send notification before threshold is reached');
  });

  describe('_processResults - correlated failure detection', () => {
    it('sends infrastructure event notification when 3+ services are down');
    it('does NOT attempt restarts during infrastructure event');
  });

  describe('restart budget', () => {
    it('allows restarts when budget has capacity');
    it('blocks restarts when budget is exhausted');
    it('resets budget after sliding window expires');
  });

  describe('autonomy gating', () => {
    it('does not restart at observe autonomy level');
    it('does not restart at cautious autonomy level');
    it('allows restart at moderate autonomy level');
    it('allows restart at full autonomy level');
  });

  describe('formatForContext', () => {
    it('returns null when no results exist');
    it('returns formatted string with service statuses');
    it('includes restart budget info');
  });

  describe('getStats', () => {
    it('returns correct up/down counts');
  });
});
```

**Implementation approach for HTTP tests:**
To test _checkHTTP without real network calls, temporarily replace `global.fetch`:
```javascript
const origFetch = global.fetch;
afterEach(() => { global.fetch = origFetch; });

it('returns up when fetch succeeds with 200', async () => {
  global.fetch = async () => ({ status: 200 });
  const hm = new HealthMonitor({ config: { health: { services: [] } } });
  const result = await hm._checkHTTP({ url: 'http://localhost:9999/', timeoutMs: 5000 });
  assert.equal(result.up, true);
  assert.equal(result.statusCode, 200);
});

it('returns up when fetch succeeds with 404', async () => {
  global.fetch = async () => ({ status: 404 });
  const hm = new HealthMonitor({ config: { health: { services: [] } } });
  const result = await hm._checkHTTP({ url: 'http://localhost:9999/', timeoutMs: 5000 });
  assert.equal(result.up, true);
});

it('returns down when fetch throws ECONNREFUSED', async () => {
  global.fetch = async () => { const err = new Error('fetch failed'); err.cause = { code: 'ECONNREFUSED' }; throw err; };
  const hm = new HealthMonitor({ config: { health: { services: [] } } });
  const result = await hm._checkHTTP({ url: 'http://localhost:9999/', timeoutMs: 5000 });
  assert.equal(result.up, false);
});
```

**For process and Docker tests:** Patch `require('child_process').execSync` before requiring health-monitor, or use the module cache approach (same pattern as session-evaluator tests):
```javascript
const cp = require('child_process');
const origExecSync = cp.execSync;
afterEach(() => { cp.execSync = origExecSync; });

it('returns up with PID when launchctl shows running service', () => {
  cp.execSync = () => '"PID" = 12345;\n"LastExitStatus" = 0;';
  const hm = new HealthMonitor({ config: { health: { services: [] } } });
  const result = hm._checkProcess({ launchdLabel: 'com.test' });
  assert.equal(result.up, true);
  assert.equal(result.pid, 12345);
});
```

**For correlated failure and autonomy tests:** Use the mock notification manager and state from helpers:
```javascript
it('sends infrastructure event when 3+ services down', () => {
  const notifications = [];
  const mockNotificationManager = { notify: (msg, tier) => notifications.push({ msg, tier }) };
  const hm = new HealthMonitor({
    config: { health: { services: [], correlatedFailureThreshold: 3, consecutiveFailsBeforeAlert: 1 } },
    notificationManager: mockNotificationManager,
  });

  // Simulate 3 services being down
  hm._results = {
    svc1: { name: 'svc1', status: 'down', consecutiveFails: 3, error: 'refused' },
    svc2: { name: 'svc2', status: 'down', consecutiveFails: 3, error: 'refused' },
    svc3: { name: 'svc3', status: 'down', consecutiveFails: 3, error: 'refused' },
  };

  hm._processResults();
  assert.equal(notifications.length, 1);
  assert.equal(notifications[0].tier, 1); // URGENT
  assert.ok(notifications[0].msg.includes('INFRASTRUCTURE EVENT'));
});
```

**For restart budget tests:**
```javascript
it('blocks restarts when budget exhausted', () => {
  const hm = new HealthMonitor({
    config: { health: { services: [], restartBudget: { maxPerHour: 2 } } },
  });
  hm._restartTimestamps = [Date.now(), Date.now()]; // 2 restarts this hour
  assert.equal(hm._checkRestartBudget(), false);
});
```

Do NOT:
- Make real HTTP requests or execute real shell commands
- Use any test framework beyond node:test and node:assert
- Skip afterEach cleanup of mocked globals/modules
  </action>
  <verify>
`node --test test/health-monitor.test.js` passes all tests.
  </verify>
  <done>
HealthMonitor has comprehensive tests covering all check types, consecutive failure tracking, correlated failure detection, restart budget, autonomy gating, and context formatting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test/mcp-bridge.test.js and update test/helpers.js</name>
  <files>test/mcp-bridge.test.js, test/helpers.js</files>
  <action>
**test/mcp-bridge.test.js:**

Use `node:test` and `node:assert` patterns. Import `{ describe, it, beforeEach, afterEach }` from `node:test` and `assert` from `node:assert/strict`.

**Test structure:**

```javascript
describe('CircuitBreaker', () => {
  it('starts in closed state');
  it('stays closed after fewer than threshold failures');
  it('opens after threshold consecutive failures');
  it('rejects calls when open');
  it('transitions to half-open after reset time');
  it('closes again after success in half-open state');
  it('re-opens after failure in half-open state');
  it('resets failure count on success');
  it('getState returns correct state object');
});

describe('MCPBridge', () => {
  describe('constructor', () => {
    it('creates circuit breakers for all known servers');
  });

  describe('isServerAvailable', () => {
    it('returns true for healthy servers');
    it('returns false when circuit breaker is open');
    it('returns true for unknown server names');
  });

  describe('queryMCP', () => {
    it('rejects immediately when circuit breaker is open');
    it('calls claudePWithSemaphore with correct options');
    it('records success on all involved servers');
    it('records failure on all involved servers when call fails');
  });

  describe('_extractServerNames', () => {
    it('extracts server name from full tool name');
    it('extracts server name from glob pattern');
    it('deduplicates server names');
    it('handles non-MCP tool names gracefully');
  });

  describe('formatForContext', () => {
    it('lists all known MCP servers');
    it('shows DISABLED for servers with open circuit breakers');
  });

  describe('getCircuitBreakerStates', () => {
    it('returns state for all known servers');
  });
});
```

**CircuitBreaker tests (pure logic, no mocking needed):**
```javascript
it('starts in closed state', () => {
  const cb = new CircuitBreaker('test');
  assert.equal(cb.state, 'closed');
  assert.equal(cb.isOpen(), false);
});

it('opens after threshold consecutive failures', () => {
  const cb = new CircuitBreaker('test', { failureThreshold: 3 });
  cb.recordFailure();
  cb.recordFailure();
  assert.equal(cb.isOpen(), false); // Only 2 failures
  cb.recordFailure();
  assert.equal(cb.isOpen(), true); // 3 failures = open
  assert.equal(cb.state, 'open');
});

it('transitions to half-open after reset time', () => {
  const cb = new CircuitBreaker('test', { failureThreshold: 1, resetTimeMs: 100 });
  cb.recordFailure();
  assert.equal(cb.isOpen(), true);

  // Wait for reset time
  cb.lastFailureTime = Date.now() - 200; // Simulate time passing
  assert.equal(cb.isOpen(), false); // Should be half-open now
  assert.equal(cb.state, 'half-open');
});

it('closes again after success in half-open state', () => {
  const cb = new CircuitBreaker('test', { failureThreshold: 1, resetTimeMs: 100 });
  cb.recordFailure();
  cb.lastFailureTime = Date.now() - 200;
  cb.isOpen(); // Trigger transition to half-open
  cb.recordSuccess();
  assert.equal(cb.state, 'closed');
  assert.equal(cb.consecutiveFailures, 0);
});
```

**MCPBridge queryMCP tests (requires mocking exec.js):**
```javascript
it('rejects immediately when circuit breaker is open', async () => {
  const mb = new MCPBridge({ failureThreshold: 1 });
  // Open the github breaker
  mb._breakers['github'].recordFailure();
  assert.equal(mb._breakers['github'].isOpen(), true);

  await assert.rejects(
    () => mb.queryMCP('test prompt', ['mcp__github__list_issues']),
    /circuit breaker is open/
  );
});

it('calls claudePWithSemaphore with correct options', async () => {
  const execModule = require('../lib/exec');
  const origFn = execModule.claudePWithSemaphore;

  let capturedArgs = null;
  execModule.claudePWithSemaphore = async (prompt, options) => {
    capturedArgs = { prompt, options };
    return 'mock response';
  };

  const mb = new MCPBridge();
  const result = await mb.queryMCP('test prompt', ['mcp__github__list_issues'], { maxTurns: 5 });

  assert.equal(result, 'mock response');
  assert.equal(capturedArgs.prompt, 'test prompt');
  assert.deepEqual(capturedArgs.options.allowedTools, ['mcp__github__list_issues']);
  assert.equal(capturedArgs.options.maxTurns, 5);

  execModule.claudePWithSemaphore = origFn;
});
```

**_extractServerNames tests:**
```javascript
it('extracts server name from full tool name', () => {
  const mb = new MCPBridge();
  const servers = mb._extractServerNames(['mcp__github__list_pull_requests']);
  assert.deepEqual(servers, ['github']);
});

it('extracts server name from glob pattern', () => {
  const mb = new MCPBridge();
  const servers = mb._extractServerNames(['mcp__docker-mcp__*']);
  assert.deepEqual(servers, ['docker-mcp']);
});

it('deduplicates server names', () => {
  const mb = new MCPBridge();
  const servers = mb._extractServerNames([
    'mcp__github__list_issues',
    'mcp__github__list_pull_requests',
  ]);
  assert.deepEqual(servers, ['github']);
});
```

---

**test/helpers.js update:**
Add mocks for the two new modules to `createMockDeps()`:
```javascript
healthMonitor: {
  checkAll: async () => {},
  getLastResults: () => ({}),
  formatForContext: () => 'Service Health: all mocked',
  getStats: () => ({ total: 0, up: 0, down: 0, services: [] }),
},
mcpBridge: {
  queryMCP: async () => 'mock MCP response',
  isServerAvailable: () => true,
  getCircuitBreakerStates: () => ({}),
  formatForContext: () => 'MCP Capabilities: all mocked',
},
```

Also add `logHealthRestart: () => {}` and `getRecentHealthRestarts: () => []` to the existing `state` mock in createMockDeps.

Do NOT:
- Make actual LLM or MCP calls in tests
- Use jest or mocha (node:test only)
- Skip afterEach cleanup of patched modules
  </action>
  <verify>
`node --test test/mcp-bridge.test.js` passes all tests.
`node --test 'test/*.test.js'` passes ALL tests (existing + new).
  </verify>
  <done>
MCPBridge and CircuitBreaker have comprehensive tests. HealthMonitor has comprehensive tests. helpers.js includes mocks for all Phase 05 modules. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
- `node --test 'test/*.test.js'` passes ALL tests (existing + new, should be 9 files total)
- No test relies on external network calls or MCP server access
- Test files follow node:test + node:assert patterns from Phase 03-04
- helpers.js createMockDeps includes healthMonitor, mcpBridge mocks
- State mock includes logHealthRestart, getRecentHealthRestarts
</verification>

<success_criteria>
All new modules have passing tests. All existing tests continue to pass. The test suite runs cleanly via `node --test 'test/*.test.js'`. Safety-critical paths (restart budget, correlated failure, autonomy gating, circuit breaker) are all covered by tests.
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure-monitoring/05-04-SUMMARY.md`
</output>
