---
phase: 05-infrastructure-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - lib/health-monitor.js
  - lib/state.js
  - index.js
autonomous: true

must_haves:
  truths:
    - "When a service accumulates 3 consecutive check failures, the user receives a tier-1 URGENT SMS notification with the service name, failure count, and error details"
    - "At moderate+ autonomy, the orchestrator restarts a failed launchd service via `launchctl kickstart -kp gui/502/<label>` or a Docker container via `docker restart`"
    - "The restart budget tracks a sliding window: max 2 restarts per hour. When exhausted, restarts are blocked and the user is notified"
    - "Correlated failure detection: if 3+ services are down simultaneously, NO restarts are attempted and a tier-1 URGENT infrastructure event SMS is sent"
    - "The orchestrator NEVER restarts itself (com.claude.orchestrator is excluded)"
    - "After a restart, the health monitor re-checks the service after 30s. If still down, it escalates to the user instead of retrying"
    - "Health check interval is wired into index.js main loop and runs on the scanIntervalMs timer"
    - "state.js tracks healthRestartHistory for restart budget persistence across check cycles"
  artifacts:
    - path: "lib/health-monitor.js"
      provides: "Alert routing, auto-restart with budget, correlated failure detection"
      contains: "restartService"
    - path: "lib/state.js"
      provides: "Health restart history persistence"
      contains: "logHealthRestart"
    - path: "index.js"
      provides: "HealthMonitor construction and check interval wiring"
      contains: "healthMonitor"
  key_links:
    - from: "lib/health-monitor.js"
      to: "lib/notification-manager.js"
      via: "notificationManager.notify() for alert routing"
      pattern: "notificationManager\\.notify"
    - from: "lib/health-monitor.js"
      to: "lib/state.js"
      via: "state.getAutonomyLevel() for restart gating"
      pattern: "getAutonomyLevel"
    - from: "index.js"
      to: "lib/health-monitor.js"
      via: "healthMonitor.checkAll() in scan interval"
      pattern: "healthMonitor\\.checkAll"
---

<objective>
Add alert routing, auto-restart with safety gates, and correlated failure detection to the HealthMonitor, then wire everything into the main orchestrator loop.

Purpose: INFRA-02 requires the orchestrator to automatically recover failed services within its autonomy level. This plan adds the restart logic with all safety constraints (budget, correlated failure, autonomy gating, self-exclusion) and connects the health monitor to the running orchestrator.
Output: Updated lib/health-monitor.js with restart and alert methods, updated lib/state.js with restart tracking, updated index.js with HealthMonitor construction and interval.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-infrastructure-monitoring/05-RESEARCH.md
@lib/health-monitor.js
@lib/state.js
@lib/notification-manager.js
@lib/context-assembler.js
@config.json
@index.js
@test/helpers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alert routing and auto-restart to health-monitor.js</name>
  <files>lib/health-monitor.js</files>
  <action>
Add the following methods and logic to the existing HealthMonitor class:

**Add to checkAll() -- after all checks complete, call processResults():**
At the end of checkAll(), after all services have been checked and recorded, add:
```javascript
this._processResults();
```

**_processResults()** (new method)
Examines all current results and triggers alerts/restarts as needed:

```javascript
_processResults() {
  const results = Object.values(this._results);
  const downServices = results.filter(r => r.status === 'down' && r.consecutiveFails >= this.consecutiveFailsBeforeAlert);

  // Correlated failure detection: 3+ services down simultaneously = infrastructure event
  const correlatedThreshold = this.config.health?.correlatedFailureThreshold || 3;
  if (downServices.length >= correlatedThreshold) {
    this._handleInfrastructureEvent(downServices);
    return;
  }

  // Process individual service failures
  for (const result of downServices) {
    const service = this.services.find(s => s.name === result.name);
    if (!service) continue;

    // Only alert/restart when consecutiveFails exactly equals threshold (first time crossing it)
    // OR on subsequent multiples of the threshold (re-alert every N failures)
    if (result.consecutiveFails === this.consecutiveFailsBeforeAlert) {
      this._handleServiceDown(service, result);
    }
  }
}
```

**_handleInfrastructureEvent(downServices)** (new method)
Send tier-1 URGENT notification. Do NOT restart anything.
```javascript
_handleInfrastructureEvent(downServices) {
  const names = downServices.map(d => d.name).join(', ');
  const msg = `INFRASTRUCTURE EVENT: ${downServices.length} services down simultaneously!\n\n` +
    `Services: ${names}\n\n` +
    `Auto-restart DISABLED (correlated failure). Manual investigation required.`;

  if (this.notificationManager) {
    this.notificationManager.notify(msg, 1); // tier 1 = URGENT
  }
  console.log(`[HEALTH] Infrastructure event: ${names}`);
}
```

**_handleServiceDown(service, result)** (new method)
Decide whether to alert-only or alert-and-restart based on autonomy level:
```javascript
_handleServiceDown(service, result) {
  const autonomyLevel = this._getAutonomyLevel();
  const canRestart = (autonomyLevel === 'moderate' || autonomyLevel === 'full');
  const hasRestartBudget = this._checkRestartBudget();
  const isRestartable = this._isRestartable(service);

  if (canRestart && hasRestartBudget && isRestartable) {
    // Attempt restart
    this._restartService(service, result);
  } else {
    // Alert only
    const reason = !canRestart ? `restart requires moderate+ (current: ${autonomyLevel})`
      : !hasRestartBudget ? 'restart budget exhausted'
      : 'service not restartable';

    const msg = `SERVICE DOWN: ${service.name}\n` +
      `${result.consecutiveFails} consecutive failures\n` +
      `Error: ${result.error || 'unknown'}\n\n` +
      `No auto-restart: ${reason}`;

    if (this.notificationManager) {
      this.notificationManager.notify(msg, 1); // tier 1 = URGENT
    }
    console.log(`[HEALTH] Service down (alert only): ${service.name} -- ${reason}`);
  }
}
```

**_restartService(service, result)** (new method)
Execute the restart and schedule a verification re-check:
```javascript
async _restartService(service, result) {
  const { execSync } = require('child_process');
  let restartCmd = null;
  let restartType = null;

  if (service.type === 'docker' && result.details?.downContainers?.length > 0) {
    // Restart first down container only (budget-conscious)
    const container = result.details.downContainers[0];
    restartCmd = `docker restart ${container}`;
    restartType = 'docker';
  } else if (service.launchdLabel) {
    restartCmd = `launchctl kickstart -kp gui/502/${service.launchdLabel}`;
    restartType = 'launchd';
  }

  if (!restartCmd) {
    console.log(`[HEALTH] No restart command for ${service.name}`);
    return;
  }

  // Record restart in budget tracker
  this._restartTimestamps.push(Date.now());

  // Send notification about the restart
  const msg = `SERVICE DOWN: ${service.name}\n` +
    `${result.consecutiveFails} consecutive failures\n` +
    `Error: ${result.error || 'unknown'}\n\n` +
    `Action: Restarting (${restartType})...`;

  if (this.notificationManager) {
    this.notificationManager.notify(msg, 2); // tier 2 = ACTION
  }

  try {
    console.log(`[HEALTH] Restarting ${service.name}: ${restartCmd}`);
    execSync(restartCmd, { encoding: 'utf-8', timeout: 15000 });
    console.log(`[HEALTH] Restart command completed for ${service.name}`);

    // Schedule verification re-check after 30 seconds
    setTimeout(async () => {
      await this._verifyRestart(service);
    }, 30000);
  } catch (err) {
    const errMsg = `Failed to restart ${service.name}: ${err.message.substring(0, 200)}`;
    console.error(`[HEALTH] ${errMsg}`);
    if (this.notificationManager) {
      this.notificationManager.notify(errMsg, 1); // tier 1 = URGENT
    }
  }
}
```

**async _verifyRestart(service)** (new method)
Re-check the service after restart. If still down, escalate.
```javascript
async _verifyRestart(service) {
  try {
    await this._checkAndRecord(service);
    const result = this._results[service.name];

    if (result?.status === 'up') {
      const msg = `SERVICE RECOVERED: ${service.name} is back up after restart.`;
      if (this.notificationManager) {
        this.notificationManager.notify(msg, 3); // tier 3 = SUMMARY
      }
      console.log(`[HEALTH] ${service.name} recovered after restart`);
    } else {
      const msg = `SERVICE STILL DOWN: ${service.name}\n` +
        `Restart did not resolve the issue. Manual investigation required.`;
      if (this.notificationManager) {
        this.notificationManager.notify(msg, 1); // tier 1 = URGENT
      }
      console.log(`[HEALTH] ${service.name} still down after restart`);
    }
  } catch (err) {
    console.error(`[HEALTH] Verify restart error for ${service.name}: ${err.message}`);
  }
}
```

**Helper methods:**

**_getAutonomyLevel()** -- reads current autonomy level from state:
```javascript
_getAutonomyLevel() {
  if (!this.state) return 'observe';
  try {
    const s = this.state.load();
    return this.state.getAutonomyLevel(s, this.config);
  } catch {
    return 'observe';
  }
}
```

**_checkRestartBudget()** -- sliding window check:
```javascript
_checkRestartBudget() {
  const maxPerHour = this.config.health?.restartBudget?.maxPerHour || 2;
  const oneHourAgo = Date.now() - 3600000;
  this._restartTimestamps = this._restartTimestamps.filter(t => t > oneHourAgo);
  return this._restartTimestamps.length < maxPerHour;
}
```

**_isRestartable(service)** -- check if we know how to restart this service:
```javascript
_isRestartable(service) {
  // Docker services with containers are restartable
  if (service.type === 'docker' && service.containers?.length > 0) return true;
  // Services with launchdLabel are restartable
  if (service.launchdLabel) return true;
  return false;
}
```

Do NOT:
- Remove or change any existing methods from 05-01
- Include `com.claude.orchestrator` in any restart logic (it is excluded from config)
- Restart more than 1 Docker container per budget slot
- Block the event loop during verification (setTimeout is non-blocking)
  </action>
  <verify>
Run `node -e "const HM = require('./lib/health-monitor'); console.log(typeof HM.prototype._processResults, typeof HM.prototype._restartService, typeof HM.prototype._checkRestartBudget)"` -- should print three 'function' strings.
  </verify>
  <done>
HealthMonitor has alert routing with tier-1 URGENT notifications, auto-restart with autonomy gating, restart budget (2/hr), correlated failure detection (3+ = infrastructure event), and post-restart verification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add restart history tracking to state.js and wire into index.js</name>
  <files>lib/state.js, index.js</files>
  <action>
**state.js changes:**

Add two new methods to StateManager, after the evaluation history section. Add a comment header: `// --- Phase 5: Health Restart History ---`

**logHealthRestart(state, record)**
- Initialize `state.healthRestartHistory` as `[]` if missing
- Push record: `{ service, type, timestamp, success }`
- Cap at 100 entries: `if (state.healthRestartHistory.length > 100) { state.healthRestartHistory = state.healthRestartHistory.slice(-100); }`
- Call `this.save(state)`

**getRecentHealthRestarts(state, count = 10)**
- Return `(state.healthRestartHistory || []).slice(-count)`

Also update the `load()` method's default return object to include `healthRestartHistory: []`.

---

**index.js changes:**

1. **Import HealthMonitor** at the top with other imports:
```javascript
const HealthMonitor = require('./lib/health-monitor');
```

2. **Construct HealthMonitor** after the notificationManager is created (since HealthMonitor depends on it), before the contextAssembler:
```javascript
// ── Health Monitor (v4.0 Phase 05) ──────────────────────────────────────────
const healthMonitor = new HealthMonitor({
  config: CONFIG,
  notificationManager,
  state,
});
```

3. **Pass healthMonitor to ContextAssembler** -- add `healthMonitor` to the constructor call:
```javascript
const contextAssembler = new ContextAssembler({
  scanner,
  sessionManager,
  processMonitor,
  state,
  config: CONFIG,
  resourceMonitor,
  healthMonitor,
});
```

4. **Add health check to the scan interval** -- in the existing `setInterval` callback that runs `proactiveScan()` and `checkSessionTimeouts()`, add `healthMonitor.checkAll()`:
```javascript
const scanInterval = setInterval(() => {
  proactiveScan();
  checkSessionTimeouts();
  healthMonitor.checkAll();
}, CONFIG.scanIntervalMs);
```

5. **Add health status to startup banner** -- add one line to the startup banner block:
```javascript
console.log(`║  Health:    ${(CONFIG.health?.enabled ? CONFIG.health.services.length + " services" : "disabled").padEnd(33)}║`);
```

6. **Clean up healthMonitor in shutdown** -- this is optional since HealthMonitor has no timers of its own. No changes needed.

Do NOT:
- Create a separate setInterval for health checks (piggyback on the existing scan interval)
- Remove or modify any existing index.js logic
- Add healthMonitor to the commands router (health status is accessed via AI context, not SMS commands)
  </action>
  <verify>
Run `node -e "const SM = require('./lib/state'); const s = new SM('/tmp/test-health-state.json'); const st = s.load(); console.log('healthRestartHistory' in st); s.logHealthRestart(st, { service: 'test', type: 'launchd', timestamp: new Date().toISOString(), success: true }); console.log(s.getRecentHealthRestarts(st)); require('fs').unlinkSync('/tmp/test-health-state.json')"` -- should show `true` and an array with the logged restart.

Run `node -c index.js` -- should syntax-check without error (does not actually run).
  </verify>
  <done>
state.js has health restart history methods. index.js constructs HealthMonitor, passes it to ContextAssembler, and runs health checks on the scan interval. Startup banner shows health service count.
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/health-monitor')"` loads without error
- `node -e "require('./lib/state')"` loads without error
- `node -c index.js` passes syntax check
- HealthMonitor has _processResults, _handleServiceDown, _restartService, _verifyRestart, _checkRestartBudget methods
- StateManager has logHealthRestart and getRecentHealthRestarts methods
- index.js constructs HealthMonitor and passes it to ContextAssembler
- No new npm dependencies added
</verification>

<success_criteria>
The health monitor detects service failures, alerts via SMS after 3 consecutive failures, auto-restarts at moderate+ autonomy with budget constraints, detects correlated failures as infrastructure events, and is wired into the running orchestrator.
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure-monitoring/05-02-SUMMARY.md`
</output>
