---
phase: 05-infrastructure-monitoring
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - lib/mcp-bridge.js
  - lib/context-assembler.js
autonomous: true

must_haves:
  truths:
    - "MCPBridge.queryMCP(prompt, tools, options) calls claudePWithSemaphore with --allowedTools and maxTurns >= 3"
    - "CircuitBreaker tracks per-MCP-server state: closed (normal), open (disabled after 3 failures), half-open (retry after 5-min cooldown)"
    - "When a circuit breaker is open, queryMCP throws immediately without consuming a semaphore slot"
    - "After a successful call in half-open state, the circuit breaker resets to closed"
    - "MCPBridge.getCircuitBreakerStates() returns all breaker states for debugging"
    - "Context assembler includes MCP capability list in the response format section"
  artifacts:
    - path: "lib/mcp-bridge.js"
      provides: "MCP integration via claude -p --allowedTools with circuit breaker protection"
      exports: ["MCPBridge", "CircuitBreaker"]
    - path: "lib/context-assembler.js"
      provides: "AI context with MCP capability awareness"
      contains: "MCP"
  key_links:
    - from: "lib/mcp-bridge.js"
      to: "lib/exec.js"
      via: "claudePWithSemaphore for gated MCP calls"
      pattern: "claudePWithSemaphore"
    - from: "lib/mcp-bridge.js"
      to: "circuit breaker pattern"
      via: "CircuitBreaker class per MCP server name"
      pattern: "CircuitBreaker"
---

<objective>
Create the MCP bridge module that enables the orchestrator to call external tools (GitHub, Docker, Calendar, Reminders, Memory) via `claude -p --allowedTools` with circuit breaker protection per MCP server.

Purpose: INFRA-03 establishes the foundation for external integrations. The orchestrator gains the ability to query GitHub for PR status, check Docker logs, read calendar events, etc. -- all protected by circuit breakers that disable flaky MCP servers after 3 consecutive failures. This module will be used more heavily in Phases 06-07.
Output: New lib/mcp-bridge.js with MCPBridge and CircuitBreaker classes. Updated context-assembler.js with MCP capability info in the AI response format.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-infrastructure-monitoring/05-RESEARCH.md
@lib/exec.js
@lib/context-assembler.js
@config.json
@test/helpers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/mcp-bridge.js</name>
  <files>lib/mcp-bridge.js</files>
  <action>
Create a module with two classes: CircuitBreaker and MCPBridge.

**CircuitBreaker class:**

```javascript
class CircuitBreaker {
  /**
   * @param {string} name - MCP server name (e.g., 'github', 'docker-mcp')
   * @param {Object} [options]
   * @param {number} [options.failureThreshold=3] - Consecutive failures before opening
   * @param {number} [options.resetTimeMs=300000] - Time before half-open (5 minutes)
   */
  constructor(name, { failureThreshold = 3, resetTimeMs = 300000 } = {}) {
    this.name = name;
    this.failureThreshold = failureThreshold;
    this.resetTimeMs = resetTimeMs;
    this.consecutiveFailures = 0;
    this.lastFailureTime = 0;
    this.state = 'closed'; // closed | open | half-open
  }

  /**
   * Check if the circuit breaker is open (blocking calls).
   * Automatically transitions to half-open when reset time has passed.
   * @returns {boolean} True if open (calls should be blocked)
   */
  isOpen() {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > this.resetTimeMs) {
        this.state = 'half-open';
        return false; // Allow one probe call
      }
      return true;
    }
    return false;
  }

  /**
   * Record a successful call. Resets failure count and closes the breaker.
   */
  recordSuccess() {
    this.consecutiveFailures = 0;
    this.state = 'closed';
  }

  /**
   * Record a failed call. Increments failure count. Opens breaker at threshold.
   */
  recordFailure() {
    this.consecutiveFailures++;
    this.lastFailureTime = Date.now();
    if (this.consecutiveFailures >= this.failureThreshold) {
      this.state = 'open';
    }
  }

  /**
   * Get current state for debugging/context.
   * @returns {{ name: string, state: string, consecutiveFailures: number, lastFailureTime: number }}
   */
  getState() {
    return {
      name: this.name,
      state: this.state,
      consecutiveFailures: this.consecutiveFailures,
      lastFailureTime: this.lastFailureTime,
    };
  }
}
```

**MCPBridge class:**

```javascript
class MCPBridge {
  /**
   * Known MCP servers available on this machine.
   * Used for circuit breaker initialization and capability reporting.
   */
  static KNOWN_SERVERS = [
    { name: 'github', description: 'GitHub repos, PRs, issues', toolPrefix: 'mcp__github__' },
    { name: 'docker-mcp', description: 'Docker containers, logs', toolPrefix: 'mcp__docker-mcp__' },
    { name: 'google-calendar', description: 'Google Calendar events', toolPrefix: 'mcp__google-calendar__' },
    { name: 'apple-mcp', description: 'Reminders, Notes, Calendar', toolPrefix: 'mcp__apple-mcp__' },
    { name: 'memory', description: 'Knowledge graph memory', toolPrefix: 'mcp__memory__' },
    { name: 'filesystem', description: 'File read/write/search', toolPrefix: 'mcp__filesystem__' },
  ];

  /**
   * @param {Object} [options]
   * @param {number} [options.failureThreshold=3] - Circuit breaker failure threshold
   * @param {number} [options.resetTimeMs=300000] - Circuit breaker reset time (5 min)
   */
  constructor(options = {}) {
    const { failureThreshold = 3, resetTimeMs = 300000 } = options;

    // Create a circuit breaker for each known MCP server
    this._breakers = {};
    for (const server of MCPBridge.KNOWN_SERVERS) {
      this._breakers[server.name] = new CircuitBreaker(server.name, {
        failureThreshold,
        resetTimeMs,
      });
    }
  }

  /**
   * Execute a prompt with MCP tool access via claude -p --allowedTools.
   *
   * @param {string} prompt - The prompt text
   * @param {string[]} tools - MCP tool names or glob patterns (e.g., ["mcp__github__*"])
   * @param {Object} [options]
   * @param {string} [options.model='sonnet'] - Model to use
   * @param {number} [options.maxTurns=3] - Must be >= 3 for MCP (tool call + result + response)
   * @param {number} [options.timeout=60000] - Timeout in ms
   * @param {string} [options.outputFormat='text'] - Output format
   * @param {string} [options.jsonSchema] - Optional JSON schema for structured output
   * @returns {Promise<string>} The response text
   * @throws {Error} If circuit breaker is open or MCP call fails
   */
  async queryMCP(prompt, tools, options = {}) {
    const {
      model = 'sonnet',
      maxTurns = 3,
      timeout = 60000,
      outputFormat = 'text',
      jsonSchema = null,
    } = options;

    // Extract MCP server names from tool names for circuit breaker routing
    // e.g., "mcp__github__list_pull_requests" -> "github"
    // e.g., "mcp__github__*" -> "github"
    const servers = this._extractServerNames(tools);

    // Check circuit breakers BEFORE consuming a semaphore slot
    for (const server of servers) {
      const breaker = this._breakers[server];
      if (breaker && breaker.isOpen()) {
        throw new Error(`MCP server '${server}' circuit breaker is open (${breaker.consecutiveFailures} consecutive failures, resets in ${Math.round((breaker.resetTimeMs - (Date.now() - breaker.lastFailureTime)) / 1000)}s)`);
      }
    }

    const { claudePWithSemaphore } = require('./exec');

    try {
      const result = await claudePWithSemaphore(prompt, {
        model,
        maxTurns,
        outputFormat: jsonSchema ? 'json' : outputFormat,
        jsonSchema,
        timeout,
        allowedTools: tools,
      });

      // Record success for all involved servers
      for (const server of servers) {
        this._breakers[server]?.recordSuccess();
      }

      return result;
    } catch (err) {
      // Record failure for all involved servers
      for (const server of servers) {
        this._breakers[server]?.recordFailure();
      }
      throw err;
    }
  }

  /**
   * Check if a specific MCP server is available (circuit breaker not open).
   * @param {string} serverName - MCP server name (e.g., 'github')
   * @returns {boolean}
   */
  isServerAvailable(serverName) {
    const breaker = this._breakers[serverName];
    if (!breaker) return true; // Unknown servers are assumed available
    return !breaker.isOpen();
  }

  /**
   * Get all circuit breaker states for debugging/context.
   * @returns {Object} Map of server name -> breaker state
   */
  getCircuitBreakerStates() {
    const states = {};
    for (const [name, breaker] of Object.entries(this._breakers)) {
      states[name] = breaker.getState();
    }
    return states;
  }

  /**
   * Format MCP capability info for AI context.
   * Shows available MCP servers and any that are circuit-broken.
   * @returns {string}
   */
  formatForContext() {
    const lines = ['MCP Capabilities (via claude -p --allowedTools):'];
    for (const server of MCPBridge.KNOWN_SERVERS) {
      const breaker = this._breakers[server.name];
      const available = breaker ? !breaker.isOpen() : true;
      const status = available ? 'available' : `DISABLED (${breaker.consecutiveFailures} failures)`;
      lines.push(`- ${server.name}: ${server.description} [${status}]`);
    }
    return lines.join('\n');
  }

  /**
   * Extract MCP server names from tool name patterns.
   * @param {string[]} tools - Tool names or glob patterns
   * @returns {string[]} Unique server names
   * @private
   */
  _extractServerNames(tools) {
    const servers = new Set();
    for (const tool of tools) {
      // Pattern: mcp__<server>__<toolname> or mcp__<server>__*
      const parts = tool.split('__');
      if (parts.length >= 2 && parts[0] === 'mcp') {
        servers.add(parts[1]);
      }
    }
    return [...servers];
  }
}
```

Export both: `module.exports = { MCPBridge, CircuitBreaker };`

Do NOT:
- Add any npm dependencies
- Create circuit breakers for servers not in KNOWN_SERVERS (they get created on demand if needed)
- Call claudeP directly (always use claudePWithSemaphore -- MCP calls must be semaphore-gated)
- Use maxTurns < 3 for MCP calls (tool call + result + response requires at least 3 turns)
  </action>
  <verify>
Run `node -e "const { MCPBridge, CircuitBreaker } = require('./lib/mcp-bridge'); console.log(typeof MCPBridge, typeof CircuitBreaker)"` -- should print 'function function'.

Run `node -e "const { CircuitBreaker } = require('./lib/mcp-bridge'); const cb = new CircuitBreaker('test'); console.log(cb.isOpen()); cb.recordFailure(); cb.recordFailure(); cb.recordFailure(); console.log(cb.isOpen()); console.log(cb.getState())"` -- should print 'false', 'true', and the state object with state: 'open'.

Run `node -e "const { MCPBridge } = require('./lib/mcp-bridge'); const mb = new MCPBridge(); console.log(mb.isServerAvailable('github')); console.log(mb.formatForContext().substring(0, 80))"` -- should print 'true' and the start of the capabilities string.
  </verify>
  <done>
MCPBridge class enables claude -p --allowedTools calls with per-server circuit breaker protection. CircuitBreaker implements closed/open/half-open state machine with configurable thresholds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add MCP capability info to context-assembler.js response format</name>
  <files>lib/context-assembler.js</files>
  <action>
Update ContextAssembler to accept and use `mcpBridge` dependency.

1. **Constructor**: Add `mcpBridge` to the destructured constructor parameter. Store as `this.mcpBridge = mcpBridge;`. It is optional (null check before use).

2. **_buildResponseFormat()**: Add MCP capability info after the existing rules section, before the final return. After the last `lines.push(...)` for the existing rules, add:

```javascript
// MCP capability awareness
if (this.mcpBridge) {
  lines.push('');
  lines.push(this.mcpBridge.formatForContext());
  lines.push('Note: MCP calls are slow (10-30s) and semaphore-gated. Use only for complex queries that cannot be done with local tools.');
}
```

This tells the AI brain what external integrations are available and warns about their performance characteristics.

Do NOT:
- Change any existing method signatures
- Make mcpBridge a required dependency (it is optional)
- Add MCP info as a separate top-level section (it belongs in the response format where the AI sees its capabilities)
  </action>
  <verify>
Run `node -e "const CA = require('./lib/context-assembler')"` -- loads without error.

Run `node -e "
const helpers = require('./test/helpers');
const CA = require('./lib/context-assembler');
const { MCPBridge } = require('./lib/mcp-bridge');
const deps = helpers.createMockDeps();
const mb = new MCPBridge();
const ca = new CA({ ...deps, mcpBridge: mb });
const ctx = ca.assemble();
console.log(ctx.includes('MCP Capabilities'));
"` -- should print 'true'.
  </verify>
  <done>
ContextAssembler shows MCP server availability and circuit breaker states in the AI brain's context, enabling the AI to reason about which external tools it can request.
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/mcp-bridge')"` loads without error
- `node -e "require('./lib/context-assembler')"` loads without error
- CircuitBreaker transitions: closed -> open after 3 failures, open -> half-open after resetTimeMs
- MCPBridge.queryMCP rejects immediately when circuit breaker is open
- MCPBridge.formatForContext() shows server availability
- Context assembler includes MCP info when mcpBridge is provided
- No new npm dependencies added
</verification>

<success_criteria>
MCPBridge enables external tool access via claude -p --allowedTools with circuit breaker protection per MCP server. The AI brain sees available MCP capabilities in its context. Foundation is ready for Phases 06-07 to use queryMCP for GitHub, Calendar, and other integrations.
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure-monitoring/05-03-SUMMARY.md`
</output>
