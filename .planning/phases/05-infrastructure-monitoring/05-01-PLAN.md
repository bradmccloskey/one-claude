---
phase: 05-infrastructure-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/health-monitor.js
  - config.json
  - lib/context-assembler.js
autonomous: true

must_haves:
  truths:
    - "HealthMonitor.checkAll() runs health checks only for services whose intervalMs has elapsed since last check"
    - "HTTP checks accept any response (including 4xx) as UP -- only connection refused, timeout, or DNS failure means DOWN"
    - "Process checks parse `launchctl list <label>` output to extract PID and LastExitStatus"
    - "Docker checks parse `docker ps --format` output to detect running vs stopped containers"
    - "HealthMonitor.getLastResults() returns cached results keyed by service name with status, latencyMs, error, consecutiveFails"
    - "HealthMonitor.formatForContext() returns a compact multi-line string for the AI brain prompt"
    - "config.json contains a health section with 8+ services covering HTTP, process, and Docker types"
    - "context-assembler.js includes a _buildHealthSection() that renders health status into AI context"
  artifacts:
    - path: "lib/health-monitor.js"
      provides: "Service health checking for HTTP, TCP, process, and Docker check types"
      exports: ["HealthMonitor"]
    - path: "config.json"
      provides: "Health service registry configuration"
      contains: "health"
    - path: "lib/context-assembler.js"
      provides: "AI context with health section"
      contains: "_buildHealthSection"
  key_links:
    - from: "lib/health-monitor.js"
      to: "native fetch"
      via: "fetch with AbortController for HTTP checks"
      pattern: "fetch.*AbortController"
    - from: "lib/health-monitor.js"
      to: "child_process"
      via: "execSync for launchctl list and docker ps"
      pattern: "execSync.*launchctl|execSync.*docker"
    - from: "lib/context-assembler.js"
      to: "lib/health-monitor.js"
      via: "healthMonitor.getLastResults() and formatForContext()"
      pattern: "healthMonitor"
---

<objective>
Create the HealthMonitor module with all four check types (HTTP, TCP, process, Docker), add the service registry to config.json, and wire health status into the AI brain's context.

Purpose: This is the foundation for all infrastructure monitoring. The orchestrator needs to know the health of 30+ services to detect outages. This plan creates the check engine and config -- alert routing and auto-restart are added in 05-02.
Output: New lib/health-monitor.js, updated config.json with health section, updated context-assembler.js with health status in AI context.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-infrastructure-monitoring/05-RESEARCH.md
@lib/exec.js
@lib/state.js
@lib/context-assembler.js
@lib/notification-manager.js
@config.json
@index.js
@test/helpers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/health-monitor.js</name>
  <files>lib/health-monitor.js</files>
  <action>
Create a HealthMonitor class following the existing DI pattern.

**Constructor:**
```javascript
constructor({ config, notificationManager, state }) {
  this.config = config;
  this.notificationManager = notificationManager;
  this.state = state;

  // Service registry from config
  this.services = config.health?.services || [];
  this.enabled = config.health?.enabled !== false;
  this.consecutiveFailsBeforeAlert = config.health?.consecutiveFailsBeforeAlert || 3;

  // Runtime tracking (in-memory, resets on restart)
  this._lastCheckTime = {};    // { serviceName: timestampMs }
  this._results = {};          // { serviceName: { status, latencyMs, error, consecutiveFails, lastChecked } }
  this._restartTimestamps = []; // For restart budget (used by 05-02)
}
```

**async checkAll()**
Main entry point. Called on an interval from index.js. For each service in the registry, check if its `intervalMs` has elapsed since its last check. If so, run the appropriate check type. This method should NOT throw -- catch all errors per service and record them as failures.

```javascript
async checkAll() {
  if (!this.enabled || this.services.length === 0) return;

  const now = Date.now();
  const checkPromises = [];

  for (const service of this.services) {
    const lastCheck = this._lastCheckTime[service.name] || 0;
    if (now - lastCheck < (service.intervalMs || 60000)) continue;

    this._lastCheckTime[service.name] = now;

    // HTTP checks can run in parallel; shell commands run sequentially after
    if (service.type === 'http' || service.type === 'tcp') {
      checkPromises.push(this._checkAndRecord(service));
    } else {
      // Process and Docker checks use execSync -- run after parallel HTTP checks
      checkPromises.push(Promise.resolve({ service, deferred: true }));
    }
  }

  // Run HTTP/TCP checks in parallel
  const results = await Promise.allSettled(checkPromises);

  // Run deferred process/docker checks sequentially
  for (const result of results) {
    if (result.status === 'fulfilled' && result.value?.deferred) {
      await this._checkAndRecord(result.value.service);
    }
  }
}
```

**async _checkAndRecord(service)**
Run the check for a single service, update `this._results[service.name]`.

```javascript
async _checkAndRecord(service) {
  const startMs = Date.now();
  let status = 'down';
  let error = null;
  let details = null;

  try {
    switch (service.type) {
      case 'http':
        details = await this._checkHTTP(service);
        status = details.up ? 'up' : 'down';
        error = details.error || null;
        break;
      case 'tcp':
        details = await this._checkTCP(service);
        status = details.up ? 'up' : 'down';
        error = details.error || null;
        break;
      case 'process':
        details = this._checkProcess(service);
        status = details.up ? 'up' : 'down';
        error = details.error || null;
        break;
      case 'docker':
        details = this._checkDocker(service);
        status = details.up ? 'up' : 'down';
        error = details.error || null;
        break;
      default:
        error = `Unknown check type: ${service.type}`;
    }
  } catch (err) {
    error = err.message;
  }

  const latencyMs = Date.now() - startMs;
  const prev = this._results[service.name];
  const consecutiveFails = status === 'down'
    ? (prev?.consecutiveFails || 0) + 1
    : 0;

  this._results[service.name] = {
    name: service.name,
    type: service.type,
    status,
    latencyMs,
    error,
    consecutiveFails,
    lastChecked: new Date().toISOString(),
    details,
  };
}
```

**async _checkHTTP(service)**
```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), service.timeoutMs || 5000);
try {
  const response = await fetch(service.url, { signal: controller.signal });
  clearTimeout(timeoutId);
  // ANY HTTP response means the service is up (even 404)
  return { up: true, statusCode: response.status };
} catch (err) {
  clearTimeout(timeoutId);
  const errorMsg = err.name === 'AbortError' ? 'timeout' : (err.cause?.code || err.message);
  return { up: false, error: errorMsg };
}
```

**async _checkTCP(service)**
Use `net.createConnection` with a Promise wrapper:
```javascript
const net = require('net');
return new Promise((resolve) => {
  const sock = net.createConnection({ host: service.host || 'localhost', port: service.port }, () => {
    sock.destroy();
    resolve({ up: true });
  });
  sock.setTimeout(service.timeoutMs || 5000);
  sock.on('timeout', () => { sock.destroy(); resolve({ up: false, error: 'timeout' }); });
  sock.on('error', (err) => { resolve({ up: false, error: err.code || err.message }); });
});
```

**_checkProcess(service)** (synchronous)
```javascript
const { execSync } = require('child_process');
try {
  const output = execSync(`launchctl list ${service.launchdLabel}`, { encoding: 'utf-8', timeout: 3000 });
  const pidMatch = output.match(/"PID"\s*=\s*(\d+)/);
  const exitMatch = output.match(/"LastExitStatus"\s*=\s*(-?\d+)/);
  const pid = pidMatch ? parseInt(pidMatch[1]) : null;
  const exitCode = exitMatch ? parseInt(exitMatch[1]) : null;
  return { up: pid !== null, pid, exitCode };
} catch (err) {
  return { up: false, error: err.message.substring(0, 200) };
}
```

**_checkDocker(service)** (synchronous)
```javascript
try {
  const output = execSync(
    'docker ps --format "{{.Names}}|{{.Status}}" 2>/dev/null',
    { encoding: 'utf-8', timeout: service.timeoutMs || 10000 }
  ).trim();

  const running = new Set();
  for (const line of output.split('\n')) {
    if (!line) continue;
    const [name, status] = line.split('|');
    if (status && status.startsWith('Up')) {
      running.add(name);
    }
  }

  const containers = service.containers || [];
  const downContainers = containers.filter(c => !running.has(c));
  return {
    up: downContainers.length === 0,
    total: containers.length,
    running: containers.length - downContainers.length,
    downContainers,
    error: downContainers.length > 0 ? `${downContainers.length} containers down` : null,
  };
} catch (err) {
  return { up: false, error: err.message.substring(0, 200), total: (service.containers || []).length, running: 0, downContainers: service.containers || [] };
}
```

**getLastResults()**
Returns a shallow copy of `this._results` (the cached check results keyed by service name).

**formatForContext()**
Build a compact multi-line string for the AI context:
```javascript
formatForContext() {
  const results = Object.values(this._results);
  if (results.length === 0) return null;

  const lines = ['Service Health:'];
  for (const r of results) {
    if (r.type === 'docker') {
      lines.push(`- ${r.name}: ${r.status === 'up' ? 'UP' : 'DOWN'} (${r.details?.running || 0}/${r.details?.total || 0} containers)`);
      if (r.details?.downContainers?.length > 0) {
        lines.push(`  Down: ${r.details.downContainers.join(', ')}`);
      }
    } else if (r.type === 'process') {
      const pidInfo = r.details?.pid ? `pid ${r.details.pid}` : 'no pid';
      lines.push(`- ${r.name}: ${r.status === 'up' ? 'UP' : 'DOWN'} (${pidInfo})`);
    } else {
      const latency = r.latencyMs ? `${r.latencyMs}ms` : '?';
      const errInfo = r.error ? ` -- ${r.error}` : '';
      lines.push(`- ${r.name}: ${r.status === 'up' ? 'UP' : 'DOWN'} (${latency})${r.consecutiveFails > 0 ? ` ${r.consecutiveFails}x fail` : ''}${errInfo}`);
    }
  }

  // Restart budget info (populated by 05-02, show if tracking exists)
  const budgetMax = this.config.health?.restartBudget?.maxPerHour || 2;
  const oneHourAgo = Date.now() - 3600000;
  const recentRestarts = this._restartTimestamps.filter(t => t > oneHourAgo).length;
  lines.push(`Restart budget: ${budgetMax - recentRestarts}/${budgetMax} remaining this hour`);

  return lines.join('\n');
}
```

**getStats()**
Returns summary stats:
```javascript
getStats() {
  const results = Object.values(this._results);
  return {
    total: results.length,
    up: results.filter(r => r.status === 'up').length,
    down: results.filter(r => r.status === 'down').length,
    services: results.map(r => ({ name: r.name, status: r.status, consecutiveFails: r.consecutiveFails })),
  };
}
```

Export: `module.exports = HealthMonitor;`

Do NOT:
- Implement alert routing or restart logic (that is 05-02)
- Add any npm dependencies (use native fetch, net, child_process)
- Monitor `com.claude.orchestrator` (self-exclusion)
- Throw from checkAll() -- all errors are caught and recorded per-service
  </action>
  <verify>
Run `node -e "const HM = require('./lib/health-monitor'); console.log(typeof HM)"` -- should print 'function'.

Run `node -e "const HM = require('./lib/health-monitor'); const hm = new HM({ config: { health: { services: [] } } }); console.log(typeof hm.checkAll, typeof hm.getLastResults, typeof hm.formatForContext)"` -- should print three 'function' strings.
  </verify>
  <done>
HealthMonitor class loads and exposes checkAll(), getLastResults(), formatForContext(), getStats(). All four check types (HTTP, TCP, process, Docker) are implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add health section to config.json</name>
  <files>config.json</files>
  <action>
Add a `health` key to the top-level config.json object. Place it after the `ai` section.

```json
"health": {
  "enabled": true,
  "services": [
    {
      "name": "income-dashboard",
      "type": "http",
      "url": "http://localhost:8060/",
      "intervalMs": 60000,
      "timeoutMs": 5000,
      "launchdLabel": "com.income-dashboard"
    },
    {
      "name": "site-monitor",
      "type": "http",
      "url": "http://localhost:8070/",
      "intervalMs": 60000,
      "timeoutMs": 5000,
      "launchdLabel": "com.site-monitor"
    },
    {
      "name": "mlx-api",
      "type": "http",
      "url": "http://localhost:8100/",
      "intervalMs": 60000,
      "timeoutMs": 5000,
      "launchdLabel": "com.mlx-inference-api"
    },
    {
      "name": "scraping-api",
      "type": "http",
      "url": "http://localhost:8002/",
      "intervalMs": 60000,
      "timeoutMs": 5000,
      "launchdLabel": "com.scraping.api"
    },
    {
      "name": "ssh-terminal",
      "type": "http",
      "url": "http://localhost:7681/",
      "intervalMs": 60000,
      "timeoutMs": 5000,
      "launchdLabel": "com.ttyd.ssh-terminal"
    },
    {
      "name": "cloudflare-tunnel",
      "type": "process",
      "launchdLabel": "com.cloudflare.scraping-api",
      "intervalMs": 120000
    },
    {
      "name": "xmr-miner",
      "type": "process",
      "launchdLabel": "com.xmr-miner",
      "intervalMs": 300000
    },
    {
      "name": "bandwidth-sharing",
      "type": "docker",
      "containers": [
        "mac-mini-m4pro_honeygain",
        "mac-mini-m4pro_earnapp",
        "mac-mini-m4pro_pawns",
        "mac-mini-m4pro_packetstream",
        "mac-mini-m4pro_proxyrack",
        "mac-mini-m4pro_repocket",
        "mac-mini-m4pro_mysterium",
        "mac-mini-m4pro_traffmonetizer",
        "mac-mini-m4pro_theta"
      ],
      "intervalMs": 300000,
      "timeoutMs": 10000
    }
  ],
  "consecutiveFailsBeforeAlert": 3,
  "restartBudget": { "maxPerHour": 2 },
  "correlatedFailureThreshold": 3
}
```

This provides 8 services (5 HTTP + 2 process + 1 Docker group with 9 containers = 30+ monitorable entities).

Do NOT:
- Include `com.claude.orchestrator` in the service list (self-monitoring is excluded)
- Modify any existing config keys
- Add watchtower to the bandwidth-sharing containers list (it is infrastructure, not a user service)
  </action>
  <verify>
Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.health.services.length, c.health.enabled)"` -- should print "8 true".

Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.health.services.map(s => s.name).join(', '))"` -- should list all 8 service names.
  </verify>
  <done>
config.json has a health section with 8 services covering HTTP, process, and Docker check types, plus alert and restart budget configuration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire health monitor into context-assembler.js</name>
  <files>lib/context-assembler.js</files>
  <action>
Update ContextAssembler to accept and use a `healthMonitor` dependency.

1. **Constructor**: Add `healthMonitor` to the destructured constructor parameter (alongside existing deps). Store as `this.healthMonitor = healthMonitor;`.

2. **assemble()**: Add a new section between the resource section (2.5) and the priorities section (3). After the `resourceSection` block:

```javascript
// 2.7. Service health
const healthSection = this._buildHealthSection();
if (healthSection) sections.push(healthSection);
```

3. **New method: _buildHealthSection()**
```javascript
_buildHealthSection() {
  if (!this.healthMonitor) return null;
  try {
    return this.healthMonitor.formatForContext();
  } catch {
    return 'Service Health: data unavailable';
  }
}
```

Do NOT:
- Change any existing method signatures or behavior
- Remove any existing sections from assemble()
- Add health monitor as a required dependency (it should be optional -- null check)
  </action>
  <verify>
Run `node -e "const CA = require('./lib/context-assembler'); console.log(typeof CA)"` -- should print 'function'.

Verify the _buildHealthSection method exists: `node -e "const CA = require('./lib/context-assembler'); console.log(typeof CA.prototype._buildHealthSection)"` -- should print 'function'.
  </verify>
  <done>
ContextAssembler accepts healthMonitor dependency and includes service health status in AI context via _buildHealthSection().
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/health-monitor')"` loads without error
- `node -e "require('./lib/context-assembler')"` loads without error
- `node -e "JSON.parse(require('fs').readFileSync('./config.json','utf-8')).health.services.length >= 8"` returns true
- HealthMonitor checkAll() runs without throwing on an empty service list
- HealthMonitor formatForContext() returns null when no results exist
- No new npm dependencies added
</verification>

<success_criteria>
HealthMonitor exists with all four check types, config.json has 8+ services in the health registry, and the AI brain sees health status in its context prompt. No alert routing or restart logic yet -- that is 05-02.
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure-monitoring/05-01-SUMMARY.md`
</output>
