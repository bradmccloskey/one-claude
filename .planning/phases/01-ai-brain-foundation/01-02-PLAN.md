---
phase: 01-ai-brain-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/state.js
  - lib/ai-brain.js
  - lib/decision-executor.js
autonomous: true

must_haves:
  truths:
    - "AI brain calls claude -p and receives parsed JSON decisions"
    - "Each think cycle is logged to .state.json aiDecisionHistory with timestamp and reasoning"
    - "Decision executor scaffold validates actions against an allowlist but does NOT execute them in observe mode"
    - "Resource checks prevent think cycle when memory is low"
  artifacts:
    - path: "lib/ai-brain.js"
      provides: "AIBrain class with think() method that shells out to claude -p"
      exports: ["AIBrain"]
    - path: "lib/decision-executor.js"
      provides: "DecisionExecutor scaffold with action allowlist and guardrails"
      exports: ["DecisionExecutor"]
    - path: "lib/state.js"
      provides: "Extended state with aiDecisionHistory persistence"
      contains: "aiDecisionHistory"
  key_links:
    - from: "lib/ai-brain.js"
      to: "lib/context-assembler.js"
      via: "assemble() to build prompt"
      pattern: "contextAssembler\\.assemble"
    - from: "lib/ai-brain.js"
      to: "claude -p"
      via: "child_process.execSync or spawn"
      pattern: "claude.*-p"
    - from: "lib/ai-brain.js"
      to: "lib/state.js"
      via: "logDecision() to persist decisions"
      pattern: "state\\.logDecision|state\\.save"
    - from: "lib/decision-executor.js"
      to: "lib/ai-brain.js"
      via: "receives parsed decisions from think cycle"
      pattern: "recommendations"
---

<objective>
Create the AI brain module that runs think cycles via `claude -p`, and scaffold the decision executor with safety guardrails. Extend state.js to persist AI decision history.

Purpose: This is the core intelligence layer. The brain assembles context, asks Claude for recommendations, parses the JSON response, logs everything, and passes decisions to the executor. In Phase 1 (observe mode), the executor only validates and formats -- it never acts.

Output: Three artifacts -- lib/ai-brain.js (think cycle engine), lib/decision-executor.js (guardrail scaffold), and extended lib/state.js (decision logging).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-ai-brain-foundation/01-01-SUMMARY.md

@lib/context-assembler.js
@lib/state.js
@config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend state.js with AI decision history and create ai-brain.js</name>
  <files>lib/state.js, lib/ai-brain.js</files>
  <action>
**1. Extend lib/state.js** -- Add two new methods to the StateManager class:

`logDecision(state, decision)`:
- `decision` is an object: `{ timestamp, prompt_length, response_raw, recommendations, summary, duration_ms, error }`
- Ensure `state.aiDecisionHistory` exists as an array
- Push the decision onto the array
- Trim array to keep only the last 50 entries (prevent unbounded growth)
- Call `this.save(state)`

`getRecentDecisions(state, count = 5)`:
- Return the last `count` entries from `state.aiDecisionHistory` (or empty array)

Update the `load()` default state to include `aiDecisionHistory: []`.

**2. Create lib/ai-brain.js** -- CommonJS module exporting `AIBrain` class.

Constructor takes: `{ contextAssembler, decisionExecutor, state, messenger, config }`

Store all deps. Also store:
- `this._thinking = false` (mutex to prevent concurrent thinks)
- `this._lastThinkTime = 0`
- `this._enabled = config.ai.enabled` (runtime toggle)

Methods:

`async think()`:
- If `!this._enabled`, return null
- If `this._thinking`, log and return null (already thinking)
- Check resource limits: call `this._checkResources()`. If fails, return null with log.
- Set `this._thinking = true` in a try/finally block
- Record `startTime = Date.now()`
- Call `const prompt = this.contextAssembler.assemble()`
- Shell out to claude: use `child_process.execSync`:
  ```
  claude -p --model ${this.config.ai.model} --max-turns 1 --output-format text
  ```
  Pass the prompt via stdin by writing it to a temp file and piping:
  ```
  execSync(`cat /tmp/orch-think-prompt.txt | claude -p --model ${model} --max-turns 1 --output-format text`, { encoding: 'utf-8', timeout: 60000 })
  ```
  (Write prompt to `/tmp/orch-think-prompt.txt` first via `fs.writeFileSync`)
- Parse the response: extract JSON from the response text. The response may contain markdown fences or extra text. Use a robust parser:
  - Try `JSON.parse(response)` first
  - If that fails, try to find `{` ... `}` with a regex that matches the outermost braces
  - If that fails, try to find content between ```json and ``` markers
  - If all fail, log error and create a fallback decision: `{ recommendations: [], summary: "Failed to parse AI response", error: "parse_error" }`
- Calculate `duration_ms = Date.now() - startTime`
- Log the decision to state via `this.state.logDecision(s, { timestamp, prompt_length, response_raw (first 500 chars), recommendations, summary, duration_ms })`
- Pass `recommendations` to `this.decisionExecutor.evaluate(recommendations)` (returns formatted results)
- Set `this._lastThinkTime = Date.now()`
- Return the decision object

`enable()` / `disable()`:
- Set `this._enabled` to true/false

`isEnabled()`:
- Return `this._enabled`

`getStatus()`:
- Return object: `{ enabled, lastThinkTime (ISO or null), thinking: this._thinking, autonomyLevel: config.ai.autonomyLevel, recentDecisions: count }`

`getLastDecision()`:
- Load state, return the most recent entry from aiDecisionHistory, or null

`_checkResources()`:
- Use `os.freemem()` to check free memory against `config.ai.resourceLimits.minFreeMemoryMB * 1024 * 1024`
- Return `{ ok: boolean, reason: string }`

`_parseJSON(text)`:
- Robust JSON extractor as described above
- Returns parsed object or null
  </action>
  <verify>
- `node -e "const SM = require('./lib/state'); const s = new SM(); const st = s.load(); s.logDecision(st, {timestamp:'2026-01-01',recommendations:[],summary:'test'}); console.log(s.load().aiDecisionHistory.length)"` prints 1
- `node -e "const AB = require('./lib/ai-brain'); console.log(typeof AB)"` prints "function"
- `node -e "const AB = require('./lib/ai-brain'); const b = new AB({contextAssembler:{assemble:()=>'test'},decisionExecutor:{evaluate:()=>[]},state:require('./lib/state').prototype,messenger:{send:()=>{}},config:require('./config.json')}); console.log(b.isEnabled())"` prints false (ai.enabled is false in config)
- Verify JSON parser handles edge cases:
```bash
node -e "
const AB = require('./lib/ai-brain');
const b = new AB({contextAssembler:{},decisionExecutor:{},state:{},messenger:{},config:require('./config.json')});
// Test various formats
const cases = [
  '{\"recommendations\":[],\"summary\":\"ok\"}',
  'Here is my analysis:\n\`\`\`json\n{\"recommendations\":[],\"summary\":\"ok\"}\n\`\`\`',
  'Based on the data, {\"recommendations\":[{\"project\":\"test\",\"action\":\"start\"}],\"summary\":\"ok\"}'
];
for (const c of cases) {
  const result = b._parseJSON(c);
  console.log(result ? 'PASS' : 'FAIL', c.substring(0,30));
}
"
```
All three should print PASS.
  </verify>
  <done>state.js has logDecision/getRecentDecisions methods, ai-brain.js has complete think cycle with claude -p integration, JSON parsing, resource checks, and enable/disable toggle</done>
</task>

<task type="auto">
  <name>Task 2: Create lib/decision-executor.js scaffold with guardrails</name>
  <files>lib/decision-executor.js</files>
  <action>
Create `lib/decision-executor.js` as a CommonJS module exporting `DecisionExecutor` class.

Constructor takes: `{ sessionManager, messenger, config }`

This is a SCAFFOLD for Phase 1. It validates and formats decisions but does NOT execute them (observe mode). Phase 2 will wire execution.

**Action allowlist** (class constant):
```javascript
static ALLOWED_ACTIONS = ['start', 'stop', 'restart', 'notify', 'skip'];
```

**Cooldown tracking** (instance):
```javascript
this._lastActionTime = {};  // key: `${project}:${action}` -> timestamp
```

Methods:

`evaluate(recommendations)`:
- Takes an array of recommendation objects from the AI brain
- For each recommendation:
  1. Validate action is in ALLOWED_ACTIONS. If not, mark as `rejected: "unknown action"`
  2. Check if project is in `config.ai.protectedProjects`. If so, mark as `rejected: "protected project"`
  3. Check cooldown: if `_lastActionTime[key]` is within `config.ai.cooldowns.sameActionMs`, mark as `rejected: "cooldown active"`
  4. If autonomyLevel is "observe", mark as `observeOnly: true` (recommend but don't act)
- Return array of evaluated recommendations with added fields: `{ ...original, validated: true/false, rejected: reason, observeOnly: true/false }`

`formatForSMS(evaluatedRecommendations)`:
- Takes the output of evaluate()
- Formats into a clean SMS-friendly text message:
  ```
  AI recommends:

  1. [project] -> [action]
     [reason]

  2. [project] -> [action]
     [reason]

  Summary: [summary from brain]

  (observe mode - no actions taken)
  ```
- Skip rejected recommendations (or show them dimmed/noted)
- Keep under 1500 chars total (truncate recommendations list if needed)
- Return the formatted string

`execute(evaluatedRecommendation)`:
- Phase 1 SCAFFOLD: Log a warning "execute() called in observe mode, ignoring" and return `{ executed: false, reason: "observe mode" }`
- This method will be wired in Phase 2 to actually call sessionManager.startSession, etc.

`_checkCooldown(project, action)`:
- Check `this._lastActionTime[${project}:${action}]` against `config.ai.cooldowns.sameActionMs`
- Also check `this._lastActionTime[${project}:*]` against `config.ai.cooldowns.sameProjectMs`
- Return `{ ok: boolean, reason: string, remainingMs: number }`

`_recordAction(project, action)`:
- Set `this._lastActionTime[${project}:${action}] = Date.now()`
  </action>
  <verify>
- `node -e "const DE = require('./lib/decision-executor'); console.log(typeof DE)"` prints "function"
- Test evaluate with mock data:
```bash
node -e "
const DE = require('./lib/decision-executor');
const de = new DE({
  sessionManager: {},
  messenger: {},
  config: require('./config.json')
});
const results = de.evaluate([
  { project: 'web-scraping-biz', action: 'start', reason: 'has work', priority: 1 },
  { project: 'test', action: 'invalid-action', reason: 'bad', priority: 5 },
]);
console.log('Valid:', results[0].validated, results[0].observeOnly);
console.log('Rejected:', results[1].validated, results[1].rejected);
"
```
Should print: `Valid: true true` and `Rejected: false unknown action`
- Test formatForSMS produces readable text:
```bash
node -e "
const DE = require('./lib/decision-executor');
const de = new DE({ sessionManager: {}, messenger: {}, config: require('./config.json') });
const evaluated = [{ project: 'web-scraping-biz', action: 'start', reason: 'Has pending work', priority: 1, validated: true, observeOnly: true }];
const sms = de.formatForSMS(evaluated, 'All projects healthy');
console.log(sms);
console.log('Length:', sms.length);
"
```
Should produce readable SMS text under 1500 chars.
  </verify>
  <done>decision-executor.js has evaluate() with allowlist/cooldown/protected project checks, formatForSMS() for observe mode notifications, and a scaffold execute() that refuses to act</done>
</task>

</tasks>

<verification>
1. state.js logDecision persists and trims to 50 entries
2. ai-brain.js think() method: assembles context, shells to claude -p, parses JSON, logs decision
3. ai-brain.js _parseJSON handles bare JSON, markdown fenced JSON, and JSON embedded in prose
4. decision-executor.js evaluate() rejects unknown actions and protected projects
5. decision-executor.js observe mode: all validated recommendations have observeOnly=true
6. No changes to existing module behavior (state.js load() still returns original fields plus new ones)
7. Zero new npm dependencies
</verification>

<success_criteria>
- ai-brain.js can run a complete think cycle (assemble -> claude -p -> parse -> log -> evaluate)
- decision-executor.js blocks invalid actions and respects cooldowns
- All decisions logged to .state.json with timestamp, duration, and recommendations
- Resource check prevents think cycle when free memory is below 2GB
- Existing v2.0 functionality completely unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/01-ai-brain-foundation/01-02-SUMMARY.md`
</output>
