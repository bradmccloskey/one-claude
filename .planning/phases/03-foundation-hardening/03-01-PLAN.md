---
phase: 03-foundation-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/exec.js
  - lib/commands.js
  - lib/ai-brain.js
autonomous: true

must_haves:
  truths:
    - "All claude -p invocations go through lib/exec.js, never raw execSync"
    - "A semaphore limits concurrent claude -p processes to 2; a third caller waits"
    - "Sending a natural language SMS never uses --dangerously-skip-permissions"
    - "The NL handler uses --max-turns 1 so it cannot run tools or loop"
  artifacts:
    - path: "lib/exec.js"
      provides: "Centralized claude -p execution with semaphore"
      exports: ["claudeP"]
      min_lines: 40
  key_links:
    - from: "lib/commands.js"
      to: "lib/exec.js"
      via: "import and call claudeP()"
      pattern: "require.*exec"
    - from: "lib/ai-brain.js"
      to: "lib/exec.js"
      via: "import and call claudeP()"
      pattern: "require.*exec"
---

<objective>
Create the centralized `lib/exec.js` wrapper for all `claude -p` invocations with a global semaphore (max 2 concurrent), and fix the NL handler's dangerous permissions.

Purpose: Every future feature (structured output, tests, session intelligence) depends on a single controlled point for shelling out to `claude -p`. The NL handler fix is a critical safety issue -- the only `claude -p` call that currently uses `--dangerously-skip-permissions` with no turn limit.

Output: `lib/exec.js` with `claudeP()` function + semaphore, `commands.js` NL handler fixed, `ai-brain.js` think/digest migrated to use exec wrapper.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/commands.js
@lib/ai-brain.js
@index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/exec.js with claudeP() and global semaphore</name>
  <files>lib/exec.js</files>
  <action>
Create `lib/exec.js` that exports a `claudeP(prompt, options)` function wrapping `execSync('claude -p ...')`.

The module must implement:

1. **claudeP(prompt, options) function:**
   - `options.model` (default: 'sonnet')
   - `options.maxTurns` (default: 1) -- always passed as `--max-turns N`
   - `options.outputFormat` (default: 'text') -- passed as `--output-format text|json`
   - `options.jsonSchema` (optional) -- if provided, pass as `--output-format json --json-schema '<schema>'` (for Plan 03)
   - `options.timeout` (default: 30000) -- passed to execSync timeout
   - `options.allowedTools` (optional) -- future use for MCP
   - NEVER include `--dangerously-skip-permissions` in any code path
   - Returns the stdout string (trimmed)
   - On timeout, throws with `.code = 'ETIMEDOUT'`
   - On non-zero exit, throws with `.stderr` attached

2. **Global semaphore (ClaudeSemaphore):**
   - Class with constructor(maxConcurrent=2)
   - `async acquire()` -- returns when a slot is available. If all slots taken, waits via a Promise queue.
   - `release()` -- frees a slot and resolves the next waiter
   - Expose `pending` getter (number of waiters) and `active` getter (number of running)
   - The semaphore wraps claudeP: export an async `claudePWithSemaphore(prompt, options)` that acquires, runs claudeP (sync), and releases in a finally block.

3. **Exports:**
   - `claudeP` (direct, no semaphore -- for tests/single-use)
   - `claudePWithSemaphore` (production use)
   - `ClaudeSemaphore` (class, for testing)
   - `_semaphore` (the singleton instance, for test inspection)

Implementation note: `claudeP` itself is synchronous (uses execSync). The semaphore makes the wrapper async. This is intentional -- `execSync` blocks the Node event loop during execution, but the semaphore gates *entry* to prevent more than 2 from blocking simultaneously.

Use `const { execSync } = require('child_process');` -- no new dependencies.
  </action>
  <verify>
    - `node -e "const e = require('./lib/exec'); console.log(typeof e.claudeP, typeof e.claudePWithSemaphore, typeof e.ClaudeSemaphore)"` prints "function function function"
    - `node -e "const e = require('./lib/exec'); console.log(e._semaphore.active, e._semaphore.pending)"` prints "0 0"
  </verify>
  <done>lib/exec.js exists, exports claudeP, claudePWithSemaphore, ClaudeSemaphore, and _semaphore. Semaphore defaults to max 2 concurrent.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate all claude -p callers to lib/exec.js and fix NL handler</name>
  <files>lib/commands.js, lib/ai-brain.js</files>
  <action>
Migrate every `execSync('claude -p ...')` call in the codebase to use `lib/exec.js`.

**In lib/commands.js `_handleNaturalLanguage()`:**
1. Replace the raw `execSync('claude -p --model ${model} --output-format text --dangerously-skip-permissions', ...)` with:
   ```js
   const { claudeP } = require('./exec');
   // ...
   const response = claudeP(prompt, {
     model,
     maxTurns: 1,
     outputFormat: 'text',
     timeout: 120000
   });
   ```
2. Remove ALL references to `--dangerously-skip-permissions` from this file
3. Remove the `const { execSync } = require('child_process');` at the top of commands.js (no longer needed)
4. Keep the existing error handling but adapt it: catch the error from claudeP (which will throw on timeout or non-zero exit) instead of catching execSync errors. The error shape is the same (has .code for timeout, .stderr for exit errors).

**In lib/ai-brain.js `think()` method:**
1. Replace `execSync('claude -p --model ${model} --max-turns 1 --output-format text', ...)` with:
   ```js
   const { claudeP } = require('./exec');
   // ...
   responseText = claudeP(prompt, {
     model,
     maxTurns: 1,
     outputFormat: 'text',
     timeout: 30000
   });
   ```
2. Keep the existing try/catch error handling around the call

**In lib/ai-brain.js `generateDigest()` method:**
1. Same pattern -- replace the `execSync` call with `claudeP()` using the same options as think() but with `timeout: 30000`.

**In lib/ai-brain.js top of file:**
1. Remove `const { execSync } = require('child_process');` (no longer needed)

Important: Do NOT add the semaphore wrapper yet to these callers. Plan 03 (structured output) will switch the production callers to `claudePWithSemaphore`. For now, the direct `claudeP` function is correct -- it centralizes the command construction and removes dangerous flags.
  </action>
  <verify>
    - `grep -r "dangerously-skip-permissions" lib/` returns NO results
    - `grep -r "execSync.*claude" lib/` returns NO results (all claude calls go through exec.js)
    - `grep -r "require.*exec" lib/commands.js lib/ai-brain.js` shows both import from './exec'
    - `node -e "require('./lib/commands')"` does not throw (module loads)
    - `node -e "require('./lib/ai-brain')"` does not throw (module loads)
  </verify>
  <done>All claude -p calls go through lib/exec.js. The NL handler no longer uses --dangerously-skip-permissions and enforces --max-turns 1. No raw execSync('claude -p ...') remains in lib/.</done>
</task>

</tasks>

<verification>
1. `grep -rn "dangerously-skip-permissions" lib/` -- must return nothing
2. `grep -rn "execSync.*claude" lib/` -- must return nothing (only exec.js uses execSync for claude)
3. `node -e "const e = require('./lib/exec'); console.log('exec OK')"` -- prints "exec OK"
4. `node -e "const e = require('./lib/exec'); console.log(e._semaphore.active === 0 && e._semaphore.pending === 0)"` -- prints "true"
5. `node -e "require('./lib/commands')"` -- loads without error
6. `node -e "require('./lib/ai-brain')"` -- loads without error
</verification>

<success_criteria>
- lib/exec.js exists with claudeP() and ClaudeSemaphore (max 2 concurrent)
- All claude -p invocations route through lib/exec.js
- --dangerously-skip-permissions is gone from the entire codebase
- NL handler in commands.js uses --max-turns 1
- All modules load without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-foundation-hardening/03-01-SUMMARY.md`
</output>
