---
phase: 03-foundation-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/commands.js
  - lib/conversation-store.js
  - lib/decision-executor.js
autonomous: true

must_haves:
  truths:
    - "Restarting the daemon preserves conversation history from before the restart"
    - "Messages older than 24 hours are automatically pruned on load"
    - "The conversation store holds at most 20 messages"
    - "Credential-like strings (API keys, tokens, passwords) are filtered before storage"
    - "The AI does not send the same recommendation SMS twice in observe mode"
    - "Dedup is content-based (hashes the project+action+reason), not just timer-based"
  artifacts:
    - path: "lib/conversation-store.js"
      provides: "Persistent conversation history with TTL, cap, credential filtering"
      exports: ["ConversationStore"]
      min_lines: 50
  key_links:
    - from: "lib/commands.js"
      to: "lib/conversation-store.js"
      via: "constructor injection, push/getRecent calls"
      pattern: "conversationStore"
    - from: "lib/decision-executor.js"
      to: "dedup hash"
      via: "content hash check before formatForSMS"
      pattern: "_recentHashes|_isDuplicate"
---

<objective>
Persist conversation history to disk so it survives daemon restarts, and implement content-based dedup for AI recommendations in observe mode.

Purpose: FOUND-04 (conversation persistence) fixes the biggest state-loss bug -- all multi-turn SMS context vanishes on restart. FOUND-06 (recommendation dedup) fixes the most user-visible annoyance -- getting the same "start web-scraping-biz" SMS every 5 minutes in observe mode.

Output: `lib/conversation-store.js` module, `commands.js` wired to persistent store, `decision-executor.js` with content-based dedup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/commands.js
@lib/decision-executor.js
@lib/state.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/conversation-store.js with persistent, TTL-capped, filtered storage</name>
  <files>lib/conversation-store.js, lib/commands.js</files>
  <action>
Create `lib/conversation-store.js`:

1. **ConversationStore class:**
   - Constructor takes `{ filePath, maxMessages, ttlMs }` with defaults:
     - `filePath`: `path.join(__dirname, '..', '.conversation-history.json')`
     - `maxMessages`: 20
     - `ttlMs`: 24 * 60 * 60 * 1000 (24 hours)
   - `push(entry)` -- adds `{ role, text, ts }` entry. Before storing, runs credential filter on `text`. Then saves to disk.
   - `getRecent(count=4)` -- loads from disk, prunes expired (ts older than now - ttlMs), prunes to maxMessages (keep newest), saves pruned list, returns last `count` entries.
   - `getAll()` -- loads, prunes, returns full array.
   - `clear()` -- writes empty array to file.

2. **Credential filtering:**
   - Before storing any `text`, strip patterns that look like secrets:
     - API keys: `/\b[A-Za-z0-9_-]{20,}\b/` only when preceded by key-like context (e.g., `key=`, `token=`, `KEY:`, `Bearer `)
     - Specific patterns: `sk-[A-Za-z0-9]{20,}` (OpenAI-style), `sk_live_[A-Za-z0-9]+` (Stripe), `ghp_[A-Za-z0-9]+` (GitHub PAT), `xoxb-[A-Za-z0-9-]+` (Slack)
     - Replace matched secrets with `[REDACTED]`
   - Keep this simple -- a `_filterCredentials(text)` method with 4-5 regex replacements.

3. **File I/O:**
   - `_load()` -- reads JSON file, returns array. On error/missing, returns `[]`.
   - `_save(entries)` -- writes JSON array to file with `JSON.stringify(entries, null, 2)`.
   - Use `fs.readFileSync` / `fs.writeFileSync` (synchronous, same pattern as state.js).

4. **Wire into commands.js:**
   - In `CommandRouter` constructor, accept `conversationStore` in deps (optional, falls back to in-memory array for backward compat).
   - Replace all `this._conversationHistory` usage:
     - `this._conversationHistory.push(...)` becomes `this.conversationStore.push(...)`
     - `this._conversationHistory.slice(-4)` becomes `this.conversationStore.getRecent(4)`
     - Remove the manual trim logic (`if (this._conversationHistory.length > 10)`)
   - Remove the `this._conversationHistory = []` from constructor.
   - In `_handleNaturalLanguage()`:
     - Build recentHistory from `this.conversationStore.getRecent(4)` instead of array slice
     - Push user message via `this.conversationStore.push({ role: 'user', text, ts: Date.now() })`
     - Push assistant response via `this.conversationStore.push({ role: 'assistant', text: finalResponse.substring(0, 200), ts: Date.now() })`

5. **Wire in index.js:**
   - Import ConversationStore
   - Create instance: `const conversationStore = new ConversationStore();`
   - Pass to CommandRouter: `conversationStore` in deps object
  </action>
  <verify>
    - `node -e "const CS = require('./lib/conversation-store'); const s = new CS({filePath: '/tmp/test-conv.json'}); s.push({role:'user',text:'hello sk-abc123def456ghi789jkl',ts:Date.now()}); console.log(s.getAll()[0].text.includes('[REDACTED]'))"` prints "true"
    - `node -e "const CS = require('./lib/conversation-store'); const s = new CS({filePath: '/tmp/test-conv2.json', maxMessages: 3}); for(let i=0;i<5;i++) s.push({role:'user',text:'msg'+i,ts:Date.now()}); console.log(s.getAll().length)"` prints "3"
    - `node -e "require('./lib/commands')"` loads without error
  </verify>
  <done>ConversationStore exists with file persistence, 24h TTL, 20 message cap, and credential filtering. CommandRouter uses it instead of in-memory array. Conversation survives daemon restart.</done>
</task>

<task type="auto">
  <name>Task 2: Add content-based recommendation dedup to decision-executor.js</name>
  <files>lib/decision-executor.js</files>
  <action>
Add content-based dedup to `DecisionExecutor` so the same recommendation is not sent via SMS twice in observe mode.

1. **In DecisionExecutor constructor:**
   - Add `this._recentHashes = new Map()` -- maps hash -> timestamp
   - Add `this._dedupTtlMs = config.ai?.dedupTtlMs || 3600000` (1 hour default)

2. **Add `_hashRecommendation(rec)` method:**
   - Create a content hash from `${rec.project}:${rec.action}:${(rec.reason || '').substring(0, 100)}`.toLowerCase()
   - Use a simple string hash (no crypto needed). Implement a basic djb2 or fnv1a hash function that returns a hex string. Example djb2:
     ```js
     _hashString(str) {
       let hash = 5381;
       for (let i = 0; i < str.length; i++) {
         hash = ((hash << 5) + hash) + str.charCodeAt(i);
         hash = hash & hash; // Convert to 32-bit integer
       }
       return (hash >>> 0).toString(16);
     }
     ```
   - Returns the hash string.

3. **Add `_isDuplicate(rec)` method:**
   - Compute hash via `_hashRecommendation(rec)`
   - Check if hash exists in `_recentHashes` and timestamp is within `_dedupTtlMs`
   - If yes, return true (duplicate)
   - If no (or expired), return false

4. **Add `_recordRecommendation(rec)` method:**
   - Compute hash, store in `_recentHashes` with current timestamp
   - Prune expired entries (iterate map, delete entries older than `_dedupTtlMs`)

5. **Modify `formatForSMS()` method:**
   - Before building the SMS text, filter out duplicates:
     ```js
     const deduped = evaluatedRecommendations.filter(r => {
       if (!r.validated) return true; // always show rejections
       if (this._isDuplicate(r)) return false; // skip dups
       this._recordRecommendation(r); // record new ones
       return true;
     });
     ```
   - Use `deduped` instead of `evaluatedRecommendations` for the rest of the method
   - If ALL valid recommendations were deduped, return null (caller should not send SMS)
   - Update the method signature JSDoc to note it may return null

6. **Update callers in index.js think cycle:**
   - Where `formatForSMS` is called, check for null return:
     ```js
     const sms = decisionExecutor.formatForSMS(evaluated, decision.summary);
     if (sms) {
       notificationManager.notify(sms, 3);
     }
     ```
   - Same check in commands.js `_handleAiThink()` where formatForSMS is called.
  </action>
  <verify>
    - `node -e "const DE = require('./lib/decision-executor'); const d = new DE({sessionManager:{},messenger:{},config:{}}); console.log(typeof d._isDuplicate, typeof d._hashRecommendation)"` prints "function function"
    - `node -e "const DE = require('./lib/decision-executor'); const d = new DE({sessionManager:{},messenger:{},config:{}}); const rec = {project:'test',action:'start',reason:'stale',validated:true}; const sms1 = d.formatForSMS([rec],'summary'); const sms2 = d.formatForSMS([rec],'summary'); console.log(sms1 !== null, sms2 === null)"` prints "true true"
  </verify>
  <done>Recommendation dedup prevents the same project+action+reason from being sent via SMS more than once per hour. formatForSMS returns null when all recommendations are duplicates. Callers check for null.</done>
</task>

</tasks>

<verification>
1. `node -e "const CS = require('./lib/conversation-store'); console.log('store OK')"` -- prints "store OK"
2. Create a ConversationStore, push 5 messages, verify file exists on disk and survives re-instantiation
3. `grep -n "_conversationHistory" lib/commands.js` -- returns no results (migrated to store)
4. `node -e "const DE = require('./lib/decision-executor'); const d = new DE({sessionManager:{},messenger:{},config:{}}); const r = {project:'x',action:'start',reason:'test',validated:true}; d.formatForSMS([r]); console.log(d.formatForSMS([r]) === null)"` -- prints "true"
5. `grep -n "_recentHashes\|_isDuplicate\|_hashRecommendation" lib/decision-executor.js` -- shows dedup methods exist
</verification>

<success_criteria>
- Conversation history persists to .conversation-history.json and survives daemon restarts
- Messages older than 24h are pruned automatically
- Max 20 messages stored
- Credential patterns (sk-, ghp_, etc.) are redacted before storage
- Duplicate recommendations (same project+action+reason) are suppressed for 1 hour
- formatForSMS returns null when all recommendations are duplicates
- index.js and commands.js handle null return from formatForSMS
</success_criteria>

<output>
After completion, create `.planning/phases/03-foundation-hardening/03-02-SUMMARY.md`
</output>
