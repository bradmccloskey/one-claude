---
phase: 03-foundation-hardening
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - lib/ai-brain.js
  - lib/context-assembler.js
  - lib/exec.js
autonomous: true

must_haves:
  truths:
    - "All AI brain responses (think cycle) are valid JSON matching their schema"
    - "No parsing fallbacks or malformed output recovery exists -- claude -p guarantees the schema"
    - "The think cycle uses claudePWithSemaphore so concurrent claude -p is limited to 2"
    - "The digest call also uses the semaphore"
    - "The NL handler in commands.js uses the semaphore"
  artifacts:
    - path: "lib/ai-brain.js"
      provides: "Think cycle with --json-schema structured output via semaphore"
      contains: "claudePWithSemaphore"
    - path: "lib/context-assembler.js"
      provides: "Context assembly without inline JSON format instructions"
  key_links:
    - from: "lib/ai-brain.js"
      to: "lib/exec.js"
      via: "claudePWithSemaphore() with jsonSchema option"
      pattern: "claudePWithSemaphore"
    - from: "lib/commands.js"
      to: "lib/exec.js"
      via: "claudePWithSemaphore() for NL handler"
      pattern: "claudePWithSemaphore"
---

<objective>
Replace all fragile JSON parsing in the AI brain with `claude -p --json-schema` constrained decoding, and switch all production claude -p callers to use the semaphore wrapper.

Purpose: FOUND-03 eliminates the 3-stage JSON parser (direct parse, fence extraction, brace extraction) that fails silently. With `--json-schema`, claude -p uses constrained decoding to guarantee valid JSON matching the schema. This also wires in the semaphore from Plan 01 to all production callers.

Output: AI brain think() returns guaranteed-schema JSON. The parseJSON() fallback method can be removed or left as dead code. All production callers use claudePWithSemaphore.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/ai-brain.js
@lib/context-assembler.js
@lib/exec.js
@lib/commands.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define JSON schemas and migrate ai-brain.js to --json-schema</name>
  <files>lib/ai-brain.js</files>
  <action>
Migrate the AI brain think() and generateDigest() to use structured output via `--json-schema`.

1. **Define the think cycle JSON schema as a constant at module level:**
   ```js
   const THINK_SCHEMA = JSON.stringify({
     type: "object",
     properties: {
       recommendations: {
         type: "array",
         items: {
           type: "object",
           properties: {
             project: { type: "string" },
             action: { type: "string", enum: ["start", "stop", "restart", "notify", "skip"] },
             reason: { type: "string" },
             priority: { type: "integer", minimum: 1, maximum: 5 },
             message: { type: "string" },
             prompt: { type: "string" },
             confidence: { type: "number", minimum: 0, maximum: 1 },
             notificationTier: { type: "integer", minimum: 1, maximum: 4 }
           },
           required: ["project", "action", "reason"]
         }
       },
       summary: { type: "string" },
       nextThinkIn: { type: "integer", minimum: 60, maximum: 1800 }
     },
     required: ["recommendations", "summary"]
   });
   ```

2. **Migrate think() method:**
   - Replace `const { claudeP } = require('./exec')` with `const { claudePWithSemaphore } = require('./exec')`
   - Change the call from synchronous `claudeP()` to `await claudePWithSemaphore()`:
     ```js
     responseText = await claudePWithSemaphore(prompt, {
       model,
       maxTurns: 1,
       jsonSchema: THINK_SCHEMA,
       timeout: 30000
     });
     ```
   - Replace the JSON parsing section: instead of `this.parseJSON(responseText)`, use `JSON.parse(responseText)` directly. The `--json-schema` flag guarantees valid JSON matching the schema.
   - Keep a try/catch around JSON.parse as a safety net, but log a warning if it ever triggers (it shouldn't with constrained decoding).
   - Remove or comment out the `parseJSON()` method. Add a comment: `// parseJSON() removed -- replaced by --json-schema constrained decoding (FOUND-03)`

3. **Migrate generateDigest() method:**
   - Use `claudePWithSemaphore` instead of `claudeP`:
     ```js
     const digestText = await claudePWithSemaphore(prompt, {
       model,
       maxTurns: 1,
       outputFormat: 'text',
       timeout: 30000
     });
     ```
   - Digest remains text output (no JSON schema needed for free-form digest text).

4. **Remove the old execSync import** if not already removed by Plan 01.

5. **Update the error handling in think():**
   - The error from claudePWithSemaphore has the same shape as before (.code for timeout, .stderr for exit errors). Keep the existing error handling structure but update the variable name if needed.
  </action>
  <verify>
    - `grep -n "parseJSON" lib/ai-brain.js` -- shows the method is removed or commented out
    - `grep -n "json-schema\|jsonSchema\|THINK_SCHEMA" lib/ai-brain.js` -- shows schema is defined and used
    - `grep -n "claudePWithSemaphore" lib/ai-brain.js` -- shows both think() and generateDigest() use semaphore
    - `node -e "require('./lib/ai-brain')"` -- loads without error
  </verify>
  <done>AI brain think() uses --json-schema for guaranteed structured output. Both think() and generateDigest() use claudePWithSemaphore. The fragile 3-stage parseJSON() is removed.</done>
</task>

<task type="auto">
  <name>Task 2: Clean up context-assembler.js response format and wire semaphore to NL handler</name>
  <files>lib/context-assembler.js, lib/commands.js</files>
  <action>
1. **In context-assembler.js `_buildResponseFormat()` method:**
   - Remove the JSON format instructions that say "Respond with a JSON object in this exact format:" and the example JSON block. The schema is now enforced by `--json-schema`, so these instructions waste prompt tokens.
   - Replace with a shorter instruction block:
     ```
     "Response format is enforced by JSON schema. Your response will be parsed as JSON automatically.",
     "",
     "Fill in the fields:",
     "- recommendations[]: array of {project, action, reason, priority, confidence, prompt?, message?, notificationTier?}",
     "- summary: one-line overall assessment",
     "- nextThinkIn: seconds until next think cycle (60-1800)",
     ```
   - Keep the autonomy level text, rules section, and action descriptions -- those are behavioral instructions, not format instructions.

2. **In lib/commands.js `_handleNaturalLanguage()`:**
   - Switch from `claudeP` to `claudePWithSemaphore`:
     ```js
     const { claudePWithSemaphore } = require('./exec');
     // ...
     const response = await claudePWithSemaphore(prompt, {
       model,
       maxTurns: 1,
       outputFormat: 'text',
       timeout: 120000
     });
     ```
   - This means `_handleNaturalLanguage` must become async. It already returns a string, but the callers need to handle the Promise.
   - Update `route()` method: when calling `_handleNaturalLanguage`, it now returns a Promise. Since `route()` is called from `pollMessages()` which is already async, change `route()` to be async and `await` the NL handler result.
   - Check all callers of `route()`:
     - In `index.js pollMessages()`: already async, change `const response = commands.route(msg.text)` to `const response = await commands.route(msg.text)`
     - In `index.js` rl.on('line'): wrap in async: `rl.on("line", async (line) => { ... const response = await commands.route(input); ... })`
   - The non-AI paths in route() (status, sessions, help, etc.) return strings synchronously. Wrapping them in async is fine -- they'll just resolve immediately.

3. **Update index.js:**
   - Adjust `pollMessages()` to await `commands.route()`
   - Adjust the readline handler to await `commands.route()`
  </action>
  <verify>
    - `grep -n "Respond with a JSON object" lib/context-assembler.js` -- returns nothing (old format instructions removed)
    - `grep -n "claudePWithSemaphore" lib/commands.js` -- shows NL handler uses semaphore
    - `grep -n "async route" lib/commands.js` -- shows route is async
    - `grep -n "await commands.route\|await.*route" index.js` -- shows callers await
    - `node -e "require('./lib/context-assembler')"` -- loads without error
    - `node -e "require('./lib/commands')"` -- loads without error
  </verify>
  <done>Context assembler no longer wastes tokens on JSON format examples. NL handler uses claudePWithSemaphore. route() is async and all callers await it. All production claude -p calls go through the semaphore.</done>
</task>

</tasks>

<verification>
1. `grep -rn "claudePWithSemaphore" lib/ai-brain.js lib/commands.js` -- both files use semaphore
2. `grep -n "parseJSON" lib/ai-brain.js` -- removed or commented out
3. `grep -n "THINK_SCHEMA" lib/ai-brain.js` -- schema constant exists
4. `grep -n "Respond with a JSON object in this exact format" lib/context-assembler.js` -- gone
5. `node -e "require('./lib/ai-brain'); require('./lib/commands'); require('./lib/context-assembler'); console.log('all OK')"` -- prints "all OK"
6. No raw `execSync('claude -p ...')` calls remain anywhere in lib/ (only lib/exec.js uses execSync)
</verification>

<success_criteria>
- AI brain think() uses --json-schema with THINK_SCHEMA constant for guaranteed structured output
- The 3-stage parseJSON() fallback is removed
- Both think() and generateDigest() use claudePWithSemaphore (semaphore-gated)
- NL handler in commands.js uses claudePWithSemaphore
- Context assembler no longer includes redundant JSON format instructions
- route() is async; all callers (pollMessages, readline) await it
- All production claude -p calls are semaphore-gated (max 2 concurrent)
</success_criteria>

<output>
After completion, create `.planning/phases/03-foundation-hardening/03-03-SUMMARY.md`
</output>
