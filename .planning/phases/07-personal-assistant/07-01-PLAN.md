---
phase: 07-personal-assistant
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/reminder-manager.js
  - lib/commands.js
  - index.js
  - config.json
autonomous: true

must_haves:
  truths:
    - "ReminderManager lazily initializes orchestrator.db with a reminders table on first access, following the same _ensureDb pattern as RevenueTracker and TrustTracker"
    - "reminders table has columns: id, text, fire_at, created_at, fired (0|1), source_message"
    - "setReminder(text, fireAtISO) inserts a pending reminder into SQLite and returns the reminder id"
    - "checkAndFire() queries pending reminders where fire_at <= now, sends each via notificationManager.notify(text, 1) with URGENT tier to bypass quiet hours, marks as fired=1"
    - "listPending() returns all unfired reminders sorted by fire_at ascending"
    - "cancelByText(query) fuzzy-matches pending reminders by text LIKE and marks them fired=1, returning the count cancelled"
    - "The NL handler in commands.js instructs the AI to include REMINDER_JSON:{...} when the user wants a reminder, parses it out, calls setReminder, and strips it from the SMS response"
    - "index.js calls reminderManager.checkAndFire() every scan cycle (60s)"
    - "config.json has a reminders section with enabled flag and timezone"
    - "Past-time reminders fire immediately (sent now, marked as fired)"
  artifacts:
    - path: "lib/reminder-manager.js"
      provides: "Reminder persistence, firing, listing, cancellation"
      exports: ["ReminderManager"]
    - path: "lib/commands.js"
      provides: "NL handler with reminder intent detection and REMINDER_JSON extraction"
      contains: "REMINDER_JSON"
    - path: "index.js"
      provides: "Scan loop integration for reminder firing"
      contains: "checkAndFire"
    - path: "config.json"
      provides: "Reminder configuration"
      contains: "reminders"
  key_links:
    - from: "lib/reminder-manager.js"
      to: "better-sqlite3"
      via: "Database constructor for orchestrator.db (shared with revenue/trust)"
      pattern: "require.*better-sqlite3"
    - from: "lib/reminder-manager.js"
      to: "lib/notification-manager.js"
      via: "notificationManager.notify() for firing reminders"
      pattern: "notificationManager\\.notify"
    - from: "lib/commands.js"
      to: "lib/reminder-manager.js"
      via: "reminderManager.setReminder() called when REMINDER_JSON detected in AI response"
      pattern: "reminderManager\\.setReminder"
    - from: "index.js"
      to: "lib/reminder-manager.js"
      via: "reminderManager.checkAndFire() polled from scan interval"
      pattern: "reminderManager\\.checkAndFire"
---

<objective>
Create the ReminderManager module that lets the user set reminders via SMS, persists them in SQLite, and fires them at the scheduled time via the notification system. Wire into the NL handler for reminder intent detection and into the scan loop for poll-based firing.

Purpose: PA-01 is the highest user-value personal assistant feature. The user texts "remind me to check YouTube OAuth tomorrow at 10am" and receives an SMS at that time. Time parsing is handled by the AI in the existing NL handler (zero new dependencies). Reminders fire via poll-based check every 60s (worst-case latency).
Output: New lib/reminder-manager.js, updated commands.js with REMINDER_JSON detection, updated index.js with scan loop integration, updated config.json with reminders section.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-personal-assistant/07-RESEARCH.md
@lib/revenue-tracker.js
@lib/trust-tracker.js
@lib/notification-manager.js
@lib/commands.js
@lib/exec.js
@lib/context-assembler.js
@config.json
@index.js
@test/helpers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/reminder-manager.js</name>
  <files>lib/reminder-manager.js</files>
  <action>
Create a ReminderManager class following the lazy-init SQLite pattern established by RevenueTracker and TrustTracker.

**Constructor:**
```javascript
'use strict';

const Database = require('better-sqlite3');
const path = require('path');

class ReminderManager {
  /**
   * @param {Object} deps
   * @param {Object} deps.config - Orchestrator config object
   * @param {Object} deps.notificationManager - NotificationManager instance for firing reminders
   */
  constructor({ config, notificationManager }) {
    this.config = config;
    this.notificationManager = notificationManager;
    this.db = null; // Lazy init
  }
}
```

**_ensureDb()** -- lazy SQLite initialization following the exact same pattern as RevenueTracker:
```javascript
_ensureDb() {
  if (this.db) return;
  const dbPath = path.join(__dirname, '..', 'orchestrator.db');
  this.db = new Database(dbPath);
  this.db.pragma('journal_mode = WAL');
  this.db.exec(`
    CREATE TABLE IF NOT EXISTS reminders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      text TEXT NOT NULL,
      fire_at TEXT NOT NULL,
      created_at TEXT NOT NULL,
      fired INTEGER DEFAULT 0,
      source_message TEXT
    )
  `);
  this.db.exec(`
    CREATE INDEX IF NOT EXISTS idx_reminders_pending
    ON reminders(fired, fire_at)
  `);
}
```

**setReminder(text, fireAtISO)** -- stores a new reminder:
```javascript
/**
 * Store a new reminder.
 * @param {string} text - What to remind about
 * @param {string} fireAtISO - ISO 8601 timestamp to fire at
 * @param {string} [sourceMessage] - Original user message for context
 * @returns {number} The reminder id
 */
setReminder(text, fireAtISO, sourceMessage = null) {
  this._ensureDb();
  const now = new Date().toISOString();

  const stmt = this.db.prepare(`
    INSERT INTO reminders (text, fire_at, created_at, fired, source_message)
    VALUES (?, ?, ?, 0, ?)
  `);

  const result = stmt.run(text, fireAtISO, now, sourceMessage);
  return result.lastInsertRowid;
}
```

**checkAndFire()** -- polled from scan loop, fires pending reminders:
```javascript
/**
 * Check for pending reminders that should fire now.
 * Called every scan cycle (60s). Fires reminders whose fire_at <= current time.
 * Uses URGENT tier (1) to bypass quiet hours since user explicitly requested the time.
 * @returns {number} Number of reminders fired
 */
checkAndFire() {
  this._ensureDb();
  const now = new Date().toISOString();

  const pending = this.db.prepare(`
    SELECT id, text, fire_at, created_at FROM reminders
    WHERE fired = 0 AND fire_at <= ?
    ORDER BY fire_at ASC
  `).all(now);

  if (pending.length === 0) return 0;

  const markFired = this.db.prepare('UPDATE reminders SET fired = 1 WHERE id = ?');

  for (const reminder of pending) {
    // Format the SMS
    const smsText = `Reminder: ${reminder.text}`;

    // Fire via notification manager with URGENT tier (bypass quiet hours)
    // User explicitly requested this time, so it should always send
    this.notificationManager.notify(smsText, 1);

    // Mark as fired
    markFired.run(reminder.id);
  }

  return pending.length;
}
```

**listPending()** -- returns all unfired reminders:
```javascript
/**
 * Get all pending (unfired) reminders sorted by fire_at.
 * @returns {Array<{id: number, text: string, fire_at: string, created_at: string}>}
 */
listPending() {
  this._ensureDb();
  return this.db.prepare(`
    SELECT id, text, fire_at, created_at FROM reminders
    WHERE fired = 0
    ORDER BY fire_at ASC
  `).all();
}
```

**cancelByText(query)** -- fuzzy-match cancellation:
```javascript
/**
 * Cancel pending reminders matching a text query.
 * Uses LIKE for fuzzy matching.
 * @param {string} query - Text to match against
 * @returns {number} Number of reminders cancelled
 */
cancelByText(query) {
  this._ensureDb();
  const result = this.db.prepare(`
    UPDATE reminders SET fired = 1
    WHERE fired = 0 AND text LIKE ?
  `).run(`%${query}%`);

  return result.changes;
}
```

**close()** -- for graceful shutdown:
```javascript
close() {
  if (this.db) {
    this.db.close();
    this.db = null;
  }
}
```

Export: `module.exports = ReminderManager;`

Do NOT:
- Add any npm dependencies
- Use node-cron for individual reminders (poll-based from scan loop is correct)
- Throw from checkAndFire (catch errors per reminder, log, continue)
- Use any tier other than URGENT (1) for fired reminders (user-requested time should bypass quiet hours)
  </action>
  <verify>
Run `node -e "const RM = require('./lib/reminder-manager'); console.log(typeof RM)"` -- should print 'function'.

Run `node -e "const RM = require('./lib/reminder-manager'); const rm = new RM({ config: {}, notificationManager: { notify: () => {} } }); console.log(typeof rm.setReminder, typeof rm.checkAndFire, typeof rm.listPending, typeof rm.cancelByText, typeof rm.close)"` -- should print five 'function' strings.
  </verify>
  <done>
ReminderManager class with SQLite persistence, poll-based firing via URGENT notifications, listing, and fuzzy cancellation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update commands.js NL handler for reminder detection</name>
  <files>lib/commands.js</files>
  <action>
Two changes to commands.js:

1. **Accept reminderManager in constructor.** Add `this.reminderManager = deps.reminderManager || null;` after the existing `this.conversationStore` line in the constructor.

2. **Update _handleNaturalLanguage() system prompt** to instruct the AI to detect reminder intent. In the `prompt` array inside `_handleNaturalLanguage()`, after the line `'IMPORTANT: Respond in plain text only. NO JSON, NO code blocks, NO markdown formatting, NO backticks.'`, add this instruction:

```
'If the user wants to set a reminder, include at the END of your response on its own line: REMINDER_JSON:{"text":"what to remind about","fireAt":"ISO-8601-timestamp"}',
'The fireAt must be an absolute ISO 8601 timestamp in America/New_York timezone. Calculate it from the current time shown below.',
'If the user wants to list reminders, cancel a reminder, or asks about reminders, say so naturally without REMINDER_JSON.',
```

3. **After receiving the AI response**, but BEFORE cleaning/truncating, detect and extract the REMINDER_JSON. Add this block right after the `const response = await claudePWithSemaphore(...)` call and the error/length checks, but BEFORE the `let cleaned = response...` block:

```javascript
// Detect and handle reminder intent
let reminderConfirmation = '';
if (this.reminderManager) {
  const reminderMatch = response.match(/REMINDER_JSON:\s*(\{[^}]+\})/);
  if (reminderMatch) {
    try {
      const reminderData = JSON.parse(reminderMatch[1]);
      if (reminderData.text && reminderData.fireAt) {
        this.reminderManager.setReminder(reminderData.text, reminderData.fireAt, text);
      }
    } catch (e) {
      console.log(`[commands] Failed to parse reminder JSON: ${e.message}`);
    }
  }

  // Handle "list reminders" intent
  const lower = text.toLowerCase();
  if (lower.includes('list reminder') || lower.includes('what reminder') || lower.includes('my reminder') || lower.includes('pending reminder')) {
    const pending = this.reminderManager.listPending();
    if (pending.length === 0) {
      reminderConfirmation = '\n\nNo pending reminders.';
    } else {
      const lines = pending.map(r => {
        const fireDate = new Date(r.fire_at);
        return `- ${r.text} (${fireDate.toLocaleString('en-US', { timeZone: 'America/New_York', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })})`;
      });
      reminderConfirmation = '\n\nPending reminders:\n' + lines.join('\n');
    }
  }

  // Handle "cancel reminder" intent
  if (lower.includes('cancel reminder') || lower.includes('delete reminder') || lower.includes('remove reminder')) {
    // Extract what to cancel (everything after "cancel/delete/remove reminder")
    const cancelMatch = lower.match(/(?:cancel|delete|remove)\s+reminder\s+(?:about\s+)?(.+)/);
    if (cancelMatch) {
      const count = this.reminderManager.cancelByText(cancelMatch[1].trim());
      reminderConfirmation = count > 0
        ? `\n\n(Cancelled ${count} reminder${count > 1 ? 's' : ''}.)`
        : '\n\n(No matching reminders found to cancel.)';
    }
  }
}
```

4. **Strip REMINDER_JSON from the cleaned response** and append any reminder confirmation. In the existing `let cleaned = response...` block, add one more .replace():

After the existing `.replace(/^\s*#+\s/gm, '')` line, add:
```javascript
.replace(/REMINDER_JSON:\s*\{[^}]+\}/g, '') // strip reminder JSON
```

5. **Append reminder confirmation** to the final response. Right before the `return finalResponse;` line, add:
```javascript
if (reminderConfirmation) {
  finalResponse = finalResponse.trimEnd() + reminderConfirmation;
}
```

Do NOT:
- Use a separate claude -p call for time parsing (the NL handler already calls claude -p, piggyback on it)
- Add a hard-coded command parser for reminders (everything goes through NL when AI is enabled)
- Remove or modify any existing command handling
- Change the constructor signature (reminderManager is added via deps, same as all other optional deps)
  </action>
  <verify>
Run `node -e "const CR = require('./lib/commands'); console.log(typeof CR)"` -- should print 'function'.

Run `node -e "const src = require('fs').readFileSync('./lib/commands.js','utf-8'); console.log(src.includes('REMINDER_JSON'), src.includes('reminderManager'), src.includes('cancelByText'))"` -- should print three 'true' values.
  </verify>
  <done>
NL handler detects reminder intent via REMINDER_JSON pattern, extracts structured data, calls setReminder, and strips the JSON from the SMS response. List and cancel intents handled inline.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire ReminderManager into index.js and config.json</name>
  <files>index.js, config.json</files>
  <action>
**index.js changes:**

1. **Import ReminderManager** after the TrustTracker import:
```javascript
const ReminderManager = require('./lib/reminder-manager');
```

2. **Instantiate ReminderManager** after the trustTracker instantiation (after the `const trustTracker = new TrustTracker(...)` line):
```javascript
// -- Reminder Manager (v4.0 Phase 07) ----------------------------------------
const reminderManager = new ReminderManager({ config: CONFIG, notificationManager });
```

3. **Inject into CommandRouter.** Update the `new CommandRouter({...})` call to include `reminderManager`:
```javascript
const commands = new CommandRouter({
  scanner,
  processMonitor,
  digest,
  scheduler,
  sessionManager,
  signalProtocol,
  state,
  projectNames: CONFIG.projects,
  aiBrain,
  decisionExecutor,
  messenger,
  conversationStore,
  reminderManager,
});
```

4. **Add checkAndFire to scan interval.** In the `setInterval(() => { ... }, CONFIG.scanIntervalMs)` callback, add after the trust metrics update block:

```javascript
  // Check pending reminders every scan cycle
  if (CONFIG.reminders?.enabled !== false) {
    try { reminderManager.checkAndFire(); } catch (e) { log('REMINDER', `Check error: ${e.message}`); }
  }
```

5. **Add to graceful shutdown.** In the `shutdown(signal)` function, before `process.exit(0)`, add:
```javascript
  reminderManager.close();
```

6. **Add startup banner line.** After the Trust line in the startup banner, add:
```javascript
console.log(`\u2551  Reminders: ${(CONFIG.reminders?.enabled !== false ? 'enabled' : 'disabled').padEnd(33)}\u2551`);
```

**config.json changes:**

Add a `reminders` section after the `weeklyRevenue` section:
```json
"reminders": {
  "enabled": true,
  "timezone": "America/New_York"
}
```

Do NOT:
- Modify the existing scan interval structure (just add the reminder check)
- Remove any existing shutdown steps
- Make reminders depend on AI being enabled (reminders fire regardless of AI on/off)
  </action>
  <verify>
Run `node -e "const src = require('fs').readFileSync('./index.js','utf-8'); console.log(src.includes('ReminderManager'), src.includes('checkAndFire'), src.includes('reminderManager.close'))"` -- should print three 'true' values.

Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.reminders.enabled, c.reminders.timezone)"` -- should print "true America/New_York".
  </verify>
  <done>
ReminderManager is instantiated, injected into CommandRouter, polled every 60s in the scan loop, and gracefully closed on shutdown. Config.json has reminders section.
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/reminder-manager')"` loads without error
- `node -e "require('./lib/commands')"` loads without error
- ReminderManager can set, list, fire, and cancel reminders
- The NL handler detects REMINDER_JSON in AI responses and calls setReminder
- Reminders fire via URGENT tier (bypass quiet hours)
- Scan loop polls checkAndFire every 60s
- Past-time reminders fire immediately (fire_at <= now on first check)
- Config.json has reminders section with timezone
- No new npm dependencies added
</verification>

<success_criteria>
The user texts "remind me to check YouTube OAuth tomorrow at 10am" and the NL handler returns a confirmation. 60 seconds later, the scan loop starts checking. At 10 AM the next day, the reminder fires as an URGENT SMS. The user can list and cancel reminders via natural language.
</success_criteria>

<output>
After completion, create `.planning/phases/07-personal-assistant/07-01-SUMMARY.md`
</output>
