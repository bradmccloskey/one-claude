---
phase: 07-personal-assistant
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - lib/conversation-store.js
  - index.js
  - lib/context-assembler.js
autonomous: true

must_haves:
  truths:
    - "ConversationStore uses SQLite (orchestrator.db) instead of JSON file for persistence, with lazy _ensureDb pattern matching RevenueTracker"
    - "conversations table has columns: id, role, text, ts (Unix ms), created_at (ISO 8601)"
    - "maxMessages is 100 (up from 20), TTL is 7 days (up from 24 hours)"
    - "push(entry) inserts a row, then prunes entries exceeding maxMessages or older than TTL"
    - "getRecent(count) returns the last N entries from SQLite after pruning"
    - "getAll() returns all non-expired entries up to maxMessages"
    - "search(query) performs a case-insensitive LIKE search across all non-expired conversation text"
    - "clear() deletes all rows from the conversations table"
    - "_filterCredentials(text) is preserved unchanged and applied before SQLite insertion"
    - "close() closes the SQLite database connection"
    - "On first run, existing .conversation-history.json is migrated into SQLite then the JSON file is deleted"
    - "The public API (push, getRecent, getAll, clear) has the same signature as before -- callers are unaffected"
    - "index.js passes the conversation store through to CommandRouter unchanged (no constructor changes needed)"
    - "ContextAssembler includes a conversation memory summary showing exchange count and most recent topic"
  artifacts:
    - path: "lib/conversation-store.js"
      provides: "SQLite-backed conversation persistence with search, expanded capacity, and credential filtering"
      exports: ["ConversationStore"]
    - path: "lib/context-assembler.js"
      provides: "AI context with conversation memory summary"
      contains: "_buildConversationSection"
  key_links:
    - from: "lib/conversation-store.js"
      to: "better-sqlite3"
      via: "Database constructor for orchestrator.db (shared with revenue/trust/reminders)"
      pattern: "require.*better-sqlite3"
    - from: "lib/conversation-store.js"
      to: "lib/commands.js"
      via: "Injected as conversationStore, called via push() and getRecent()"
      pattern: "conversationStore\\.push|conversationStore\\.getRecent"
    - from: "lib/context-assembler.js"
      to: "lib/conversation-store.js"
      via: "conversationStore.getAll() for memory summary in context"
      pattern: "conversationStore"
---

<objective>
Migrate ConversationStore from JSON file to SQLite, expand to 100 messages with 7-day TTL, add keyword search, and integrate conversation memory into the AI context. On first run, migrate existing JSON history.

Purpose: PA-02 gives the orchestrator long-term conversation memory. The user said something 3 days ago? The AI remembers. The current 20-message, 24h TTL, JSON-backed store is too limited for a personal assistant. SQLite enables keyword search and integrates with the shared orchestrator.db used by revenue, trust, and reminders.
Output: Rewritten lib/conversation-store.js with SQLite backend, updated context-assembler.js with conversation summary, backward-compatible API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-personal-assistant/07-RESEARCH.md
@lib/conversation-store.js
@lib/revenue-tracker.js
@lib/commands.js
@lib/context-assembler.js
@index.js
@test/helpers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite lib/conversation-store.js with SQLite backend</name>
  <files>lib/conversation-store.js</files>
  <action>
Replace the entire JSON-based implementation with SQLite while preserving the exact same public API (push, getRecent, getAll, clear) and _filterCredentials.

```javascript
'use strict';

const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');

/**
 * ConversationStore - SQLite-backed conversation history with TTL, cap, and credential filtering.
 *
 * Stores conversation entries in orchestrator.db (shared with revenue, trust, reminders).
 * Automatically prunes messages older than TTL and caps total messages.
 * Credential-like strings are redacted before storage.
 *
 * Migrated from JSON file in Phase 07 (was .conversation-history.json).
 */
class ConversationStore {
  /**
   * @param {Object} [options]
   * @param {string} [options.dbPath] - Path to SQLite database (default: orchestrator.db)
   * @param {number} [options.maxMessages=100] - Maximum messages to retain
   * @param {number} [options.ttlMs=604800000] - Time-to-live in ms (default 7 days)
   */
  constructor({ dbPath, maxMessages, ttlMs } = {}) {
    this.dbPath = dbPath || path.join(__dirname, '..', 'orchestrator.db');
    this.maxMessages = maxMessages || 100;
    this.ttlMs = ttlMs || 7 * 24 * 60 * 60 * 1000; // 7 days
    this.db = null; // Lazy init
    this._migrationDone = false;
  }

  /**
   * Lazy SQLite initialization following the same pattern as RevenueTracker.
   * Also handles one-time migration from JSON file.
   * @private
   */
  _ensureDb() {
    if (this.db) return;
    this.db = new Database(this.dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS conversations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        role TEXT NOT NULL,
        text TEXT NOT NULL,
        ts INTEGER NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_conversations_ts
      ON conversations(ts)
    `);

    // One-time migration from JSON file
    if (!this._migrationDone) {
      this._migrateFromJSON();
      this._migrationDone = true;
    }
  }

  /**
   * Migrate existing .conversation-history.json into SQLite.
   * Runs once on first _ensureDb call. Deletes the JSON file after successful migration.
   * @private
   */
  _migrateFromJSON() {
    const jsonPath = path.join(__dirname, '..', '.conversation-history.json');
    try {
      if (!fs.existsSync(jsonPath)) return;

      const data = fs.readFileSync(jsonPath, 'utf-8');
      const entries = JSON.parse(data);
      if (!Array.isArray(entries) || entries.length === 0) {
        fs.unlinkSync(jsonPath);
        return;
      }

      const insert = this.db.prepare(`
        INSERT INTO conversations (role, text, ts, created_at)
        VALUES (?, ?, ?, ?)
      `);

      const insertMany = this.db.transaction((rows) => {
        for (const entry of rows) {
          if (!entry.role || !entry.text) continue;
          const ts = entry.ts || Date.now();
          const createdAt = new Date(ts).toISOString();
          insert.run(entry.role, entry.text, ts, createdAt);
        }
      });

      insertMany(entries);
      fs.unlinkSync(jsonPath);
      console.log(`[ConversationStore] Migrated ${entries.length} entries from JSON to SQLite`);
    } catch (e) {
      console.log(`[ConversationStore] Migration warning: ${e.message}`);
      // Don't fail initialization if migration fails
    }
  }

  /**
   * Add a conversation entry. Filters credentials from text before persisting.
   * @param {Object} entry - { role: string, text: string, ts: number }
   */
  push(entry) {
    this._ensureDb();

    const filtered = {
      role: entry.role,
      text: this._filterCredentials(entry.text || ''),
      ts: entry.ts || Date.now(),
    };

    const createdAt = new Date(filtered.ts).toISOString();

    this.db.prepare(`
      INSERT INTO conversations (role, text, ts, created_at)
      VALUES (?, ?, ?, ?)
    `).run(filtered.role, filtered.text, filtered.ts, createdAt);

    // Prune on insert
    this._prune();
  }

  /**
   * Get the most recent entries, after pruning expired messages.
   * @param {number} [count=4] - Number of recent entries to return
   * @returns {Array} Last `count` entries
   */
  getRecent(count = 4) {
    this._ensureDb();
    this._prune();

    const rows = this.db.prepare(`
      SELECT role, text, ts FROM conversations
      ORDER BY ts DESC
      LIMIT ?
    `).all(count);

    // Return in chronological order (oldest first)
    return rows.reverse();
  }

  /**
   * Get all entries after pruning expired messages.
   * @returns {Array} All non-expired entries (up to maxMessages)
   */
  getAll() {
    this._ensureDb();
    this._prune();

    return this.db.prepare(`
      SELECT role, text, ts FROM conversations
      ORDER BY ts ASC
    `).all();
  }

  /**
   * Search conversation history for entries matching a keyword query.
   * Case-insensitive LIKE search across all non-expired entries.
   * @param {string} query - Search term
   * @returns {Array} Matching entries sorted by recency
   */
  search(query) {
    this._ensureDb();
    this._prune();

    if (!query || query.trim().length === 0) return [];

    return this.db.prepare(`
      SELECT role, text, ts FROM conversations
      WHERE text LIKE ?
      ORDER BY ts DESC
      LIMIT 20
    `).all(`%${query}%`);
  }

  /**
   * Clear all conversation history.
   */
  clear() {
    this._ensureDb();
    this.db.prepare('DELETE FROM conversations').run();
  }

  /**
   * Close the SQLite database connection.
   */
  close() {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }

  /**
   * Prune expired entries (older than TTL) and cap to maxMessages.
   * @private
   */
  _prune() {
    const cutoffTs = Date.now() - this.ttlMs;

    // Remove expired entries
    this.db.prepare('DELETE FROM conversations WHERE ts < ?').run(cutoffTs);

    // Cap to maxMessages (keep newest)
    const count = this.db.prepare('SELECT COUNT(*) as cnt FROM conversations').get().cnt;
    if (count > this.maxMessages) {
      const excess = count - this.maxMessages;
      this.db.prepare(`
        DELETE FROM conversations WHERE id IN (
          SELECT id FROM conversations ORDER BY ts ASC LIMIT ?
        )
      `).run(excess);
    }
  }

  /**
   * Filter credential-like strings from text, replacing with [REDACTED].
   * Preserved from the original JSON-backed implementation.
   * @param {string} text
   * @returns {string} Text with credentials redacted
   * @private
   */
  _filterCredentials(text) {
    if (!text) return text;

    let filtered = text;

    // OpenAI-style keys: sk-...
    filtered = filtered.replace(/\bsk-[A-Za-z0-9]{20,}\b/g, '[REDACTED]');

    // Stripe live keys: sk_live_...
    filtered = filtered.replace(/\bsk_live_[A-Za-z0-9]+\b/g, '[REDACTED]');

    // GitHub PATs: ghp_...
    filtered = filtered.replace(/\bghp_[A-Za-z0-9]+\b/g, '[REDACTED]');

    // Slack bot tokens: xoxb-...
    filtered = filtered.replace(/\bxoxb-[A-Za-z0-9-]+\b/g, '[REDACTED]');

    // Generic key/token/bearer contexts: key=VALUE, token=VALUE, Bearer VALUE, KEY: VALUE
    filtered = filtered.replace(
      /(?:key=|token=|KEY:|TOKEN:|Bearer\s+)([A-Za-z0-9_\-]{20,})\b/gi,
      (match, secret) => match.replace(secret, '[REDACTED]')
    );

    return filtered;
  }
}

module.exports = ConversationStore;
```

The key changes from the original:
- JSON file -> SQLite (orchestrator.db)
- maxMessages: 20 -> 100
- TTL: 24h -> 7 days
- Added: search(query), close(), _migrateFromJSON()
- Preserved: _filterCredentials() (exact same implementation)
- Preserved: public API (push, getRecent, getAll, clear)
- Constructor signature: `{ filePath, maxMessages, ttlMs }` -> `{ dbPath, maxMessages, ttlMs }` (filePath is gone, dbPath is new but optional)

Do NOT:
- Change the _filterCredentials implementation
- Remove any existing public methods
- Make the DB path non-configurable (tests need to override it)
- Use FTS5 (overkill for 100 rows, LIKE is fine)
  </action>
  <verify>
Run `node -e "const CS = require('./lib/conversation-store'); console.log(typeof CS)"` -- should print 'function'.

Run `node -e "const CS = require('./lib/conversation-store'); const cs = new CS(); console.log(typeof cs.push, typeof cs.getRecent, typeof cs.getAll, typeof cs.clear, typeof cs.search, typeof cs.close)"` -- should print six 'function' strings.
  </verify>
  <done>
ConversationStore rewritten with SQLite backend. 100 message cap, 7-day TTL, keyword search, JSON migration, credential filtering preserved, backward-compatible API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conversation memory to ContextAssembler and update index.js</name>
  <files>lib/context-assembler.js, index.js</files>
  <action>
**context-assembler.js changes:**

1. **Accept conversationStore in constructor.** Add `conversationStore` to the destructured constructor parameter and store it:
In the constructor, after `this.trustTracker = trustTracker;`, add:
```javascript
this.conversationStore = conversationStore;
```

Also update the constructor signature to include `conversationStore` in the destructured parameters.

2. **Add _buildConversationSection() method** after the existing _buildTrustSection():

```javascript
/**
 * Build conversation memory summary for AI context.
 * Shows exchange count and recent conversation topics.
 * Returns null if conversationStore is not available or empty.
 * @returns {string|null}
 */
_buildConversationSection() {
  if (!this.conversationStore) return null;
  try {
    const all = this.conversationStore.getAll();
    if (all.length === 0) return null;

    const recent = all.slice(-6); // Last 6 entries for context
    const lines = [`Conversation Memory (${all.length} exchanges, 7-day window):`];

    for (const entry of recent) {
      const age = Math.round((Date.now() - entry.ts) / 60000);
      const ageStr = age < 60 ? `${age}min ago` : age < 1440 ? `${Math.round(age / 60)}h ago` : `${Math.round(age / 1440)}d ago`;
      const preview = entry.text.length > 80 ? entry.text.substring(0, 80) + '...' : entry.text;
      lines.push(`- [${entry.role}] ${preview} (${ageStr})`);
    }

    return lines.join('\n');
  } catch {
    return null;
  }
}
```

3. **Wire into assemble().** In the `assemble()` method, after the trust section (after the `if (trustSection) sections.push(trustSection);` line), add:

```javascript
// 2.95. Conversation memory
const conversationSection = this._buildConversationSection();
if (conversationSection) sections.push(conversationSection);
```

**index.js changes:**

1. **Pass conversationStore to ContextAssembler.** In the `new ContextAssembler({...})` constructor call, add `conversationStore` after `trustTracker`:

```javascript
const contextAssembler = new ContextAssembler({
  scanner,
  sessionManager,
  processMonitor,
  state,
  config: CONFIG,
  resourceMonitor,
  healthMonitor,
  revenueTracker,
  trustTracker,
  conversationStore,
});
```

Note: The `conversationStore` variable is already declared at line 100 of index.js, but the ContextAssembler is declared BEFORE it (line 71). The fix: move the `const conversationStore = new ConversationStore();` line to BEFORE the ContextAssembler instantiation, right after the trustTracker line. So move it from line 100 to after the TrustTracker block.

2. **Add close() to graceful shutdown.** In the shutdown function, before `process.exit(0)`, add:
```javascript
conversationStore.close();
```

Do NOT:
- Change the constructor signature of ContextAssembler in a way that breaks existing callers (conversationStore is optional)
- Include full conversation text in the context (only previews -- the context has length limits)
- Move the ConversationStore import -- it already exists at the top of index.js
  </action>
  <verify>
Run `node -e "const CA = require('./lib/context-assembler'); console.log(typeof CA.prototype._buildConversationSection)"` -- should print 'function'.

Run `node -e "const src = require('fs').readFileSync('./index.js','utf-8'); console.log(src.includes('conversationStore,'))"` -- should find conversationStore passed to ContextAssembler (the trailing comma distinguishes it from other mentions).
  </verify>
  <done>
ContextAssembler shows conversation memory summary in AI context. ConversationStore passed to both ContextAssembler and CommandRouter. Graceful shutdown closes the database.
  </done>
</task>

</tasks>

<verification>
- `node -e "require('./lib/conversation-store')"` loads without error
- `node -e "require('./lib/context-assembler')"` loads without error
- ConversationStore can push, getRecent, getAll, search, and clear
- Credential filtering is preserved (test with a ghp_ token)
- JSON migration works (if .conversation-history.json exists, entries move to SQLite)
- search() returns matching entries with case-insensitive LIKE
- TTL is 7 days, maxMessages is 100
- ContextAssembler includes conversation memory when available
- No new npm dependencies added
</verification>

<success_criteria>
ConversationStore uses SQLite with 100 message cap and 7-day TTL. Existing JSON history is migrated on first run. The AI context includes a conversation memory summary showing recent exchanges. The user's preferences and facts from past conversations are accessible via keyword search. All callers (commands.js, index.js) work unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/07-personal-assistant/07-02-SUMMARY.md`
</output>
