---
phase: 07-personal-assistant
plan: 04
type: execute
wave: 4
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - lib/session-learner.js
  - lib/session-evaluator.js
  - lib/context-assembler.js
  - index.js
  - config.json
  - test/reminder-manager.test.js
  - test/conversation-store.test.js
  - test/session-learner.test.js
  - test/helpers.js
autonomous: true

must_haves:
  truths:
    - "SessionLearner lazily initializes orchestrator.db with a session_evaluations table, following the same _ensureDb pattern"
    - "session_evaluations table has columns: id, session_id, project_name, started_at, stopped_at, duration_minutes, commit_count, insertions, deletions, files_changed, score, recommendation, prompt_snippet, prompt_style, evaluated_at"
    - "recordEvaluation(eval) inserts an evaluation record into SQLite with prompt_style classified by keyword matching (fix/implement/explore/resume/custom)"
    - "analyzePatterns() returns pattern insights only when 50+ evaluations exist, null below threshold"
    - "Pattern analysis includes: avg score by project, avg score by prompt style, optimal duration range, time-of-day patterns"
    - "formatForContext() returns a cached pattern summary string or 'Insufficient data (N/50 evaluations)'"
    - "SessionEvaluator.evaluate() additionally calls sessionLearner.recordEvaluation() to dual-write to SQLite"
    - "ContextAssembler includes session learnings section when sessionLearner is provided"
    - "index.js instantiates SessionLearner, passes to SessionEvaluator and ContextAssembler, closes on shutdown"
    - "config.json has a learning section with minEvaluations threshold (default 50) and analysisInterval (default 10)"
    - "Reminder manager tests verify setReminder, checkAndFire, listPending, cancelByText, and past-time firing"
    - "Conversation store tests verify SQLite schema, push, getRecent, getAll, search, clear, credential filtering, and TTL pruning"
    - "Session learner tests verify schema, recordEvaluation, prompt style classification, analyzePatterns threshold, and formatForContext"
    - "Running `node --test 'test/*.test.js'` passes ALL tests including new test files"
  artifacts:
    - path: "lib/session-learner.js"
      provides: "Session evaluation persistence and pattern analysis"
      exports: ["SessionLearner"]
    - path: "lib/session-evaluator.js"
      provides: "Session evaluation with dual-write to SQLite"
      contains: "sessionLearner"
    - path: "lib/context-assembler.js"
      provides: "AI context with session learning patterns"
      contains: "_buildLearningsSection"
    - path: "test/reminder-manager.test.js"
      provides: "Tests for ReminderManager module"
      contains: "describe.*ReminderManager"
    - path: "test/conversation-store.test.js"
      provides: "Tests for ConversationStore SQLite migration"
      contains: "describe.*ConversationStore"
    - path: "test/session-learner.test.js"
      provides: "Tests for SessionLearner module"
      contains: "describe.*SessionLearner"
  key_links:
    - from: "lib/session-learner.js"
      to: "better-sqlite3"
      via: "Database constructor for orchestrator.db"
      pattern: "require.*better-sqlite3"
    - from: "lib/session-evaluator.js"
      to: "lib/session-learner.js"
      via: "sessionLearner.recordEvaluation(evaluation)"
      pattern: "sessionLearner\\.recordEvaluation"
    - from: "lib/context-assembler.js"
      to: "lib/session-learner.js"
      via: "sessionLearner.formatForContext()"
      pattern: "sessionLearner\\.formatForContext"
    - from: "test/reminder-manager.test.js"
      to: "lib/reminder-manager.js"
      via: "require and class instantiation with temp DB"
      pattern: "require.*reminder-manager"
    - from: "test/conversation-store.test.js"
      to: "lib/conversation-store.js"
      via: "require and class instantiation with temp DB"
      pattern: "require.*conversation-store"
---

<objective>
Create the SessionLearner module that stores evaluation data in SQLite for pattern analysis, wire it into the evaluation pipeline and AI context, and create comprehensive tests for all Phase 07 modules (reminder manager, conversation store, session learner).

Purpose: PA-04 closes the learning loop -- after 50+ evaluations, the orchestrator identifies which prompt styles, session durations, and project approaches yield the best scores. This plan also ensures all Phase 07 modules have test coverage. Tests are last because they need the final implementations.
Output: New lib/session-learner.js, updated session-evaluator.js with dual-write, updated context-assembler.js with learnings section, three new test files, updated helpers.js.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-personal-assistant/07-RESEARCH.md
@lib/session-evaluator.js
@lib/context-assembler.js
@lib/reminder-manager.js
@lib/conversation-store.js
@config.json
@index.js
@test/helpers.js
@test/revenue-tracker.test.js
@test/trust-tracker.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/session-learner.js</name>
  <files>lib/session-learner.js</files>
  <action>
Create a SessionLearner class following the lazy-init SQLite pattern.

```javascript
'use strict';

const Database = require('better-sqlite3');
const path = require('path');

/**
 * SessionLearner - Stores evaluation data in SQLite and identifies patterns
 * in prompt styles, session durations, and project approaches that yield
 * the best evaluation scores.
 *
 * Pattern analysis only activates after a configurable threshold (default 50)
 * evaluations have been recorded.
 */
class SessionLearner {
  /**
   * @param {Object} deps
   * @param {Object} deps.config - Orchestrator config object
   */
  constructor({ config }) {
    this.config = config;
    this.db = null; // Lazy init
    this._cachedPatterns = null;
    this._evalCountAtLastAnalysis = 0;
  }

  /**
   * Lazy SQLite initialization.
   * @private
   */
  _ensureDb() {
    if (this.db) return;
    const dbPath = path.join(__dirname, '..', 'orchestrator.db');
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS session_evaluations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,
        project_name TEXT NOT NULL,
        started_at TEXT NOT NULL,
        stopped_at TEXT,
        duration_minutes INTEGER,
        commit_count INTEGER,
        insertions INTEGER,
        deletions INTEGER,
        files_changed INTEGER,
        score INTEGER,
        recommendation TEXT,
        prompt_snippet TEXT,
        prompt_style TEXT,
        evaluated_at TEXT NOT NULL
      )
    `);
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_evals_project
      ON session_evaluations(project_name)
    `);
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_evals_score
      ON session_evaluations(score)
    `);
  }

  /**
   * Record a session evaluation in SQLite.
   * Called from SessionEvaluator.evaluate() to dual-write alongside state.json.
   *
   * @param {Object} evaluation - The evaluation record from SessionEvaluator
   */
  recordEvaluation(evaluation) {
    this._ensureDb();

    const promptSnippet = (evaluation.prompt || '').substring(0, 200);
    const promptStyle = this._classifyPromptStyle(evaluation.prompt || '');

    this.db.prepare(`
      INSERT INTO session_evaluations
        (session_id, project_name, started_at, stopped_at, duration_minutes,
         commit_count, insertions, deletions, files_changed,
         score, recommendation, prompt_snippet, prompt_style, evaluated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      evaluation.sessionId || '',
      evaluation.projectName || '',
      evaluation.startedAt || '',
      evaluation.stoppedAt || null,
      evaluation.durationMinutes || null,
      evaluation.gitProgress?.commitCount ?? null,
      evaluation.gitProgress?.insertions ?? null,
      evaluation.gitProgress?.deletions ?? null,
      evaluation.gitProgress?.filesChanged ?? null,
      evaluation.score ?? null,
      evaluation.recommendation || null,
      promptSnippet,
      promptStyle,
      evaluation.evaluatedAt || new Date().toISOString(),
    );

    // Invalidate cache if analysis interval reached
    const analysisInterval = this.config.learning?.analysisInterval || 10;
    const totalEvals = this._getEvalCount();
    if (totalEvals - this._evalCountAtLastAnalysis >= analysisInterval) {
      this._cachedPatterns = null;
    }
  }

  /**
   * Classify a prompt into a style category based on keywords.
   * @param {string} prompt
   * @returns {string} One of: fix, implement, explore, resume, custom
   * @private
   */
  _classifyPromptStyle(prompt) {
    const lower = prompt.toLowerCase();
    if (lower.includes('fix') || lower.includes('bug') || lower.includes('error')) return 'fix';
    if (lower.includes('implement') || lower.includes('add') || lower.includes('create') || lower.includes('build')) return 'implement';
    if (lower.includes('explore') || lower.includes('read') || lower.includes('understand') || lower.includes('investigate')) return 'explore';
    if (lower.includes('resume') || lower.includes('continue') || lower.includes('left off')) return 'resume';
    return 'custom';
  }

  /**
   * Get total evaluation count.
   * @returns {number}
   * @private
   */
  _getEvalCount() {
    this._ensureDb();
    return this.db.prepare('SELECT COUNT(*) as cnt FROM session_evaluations').get().cnt;
  }

  /**
   * Analyze patterns across all evaluations.
   * Returns null if below the minimum evaluation threshold.
   *
   * @returns {Object|null} Pattern insights or null if insufficient data
   */
  analyzePatterns() {
    this._ensureDb();

    const minEvals = this.config.learning?.minEvaluations || 50;
    const totalEvals = this._getEvalCount();

    if (totalEvals < minEvals) {
      return null;
    }

    const patterns = {};

    // Average score by project (min 3 sessions)
    patterns.byProject = this.db.prepare(`
      SELECT project_name, AVG(score) as avg_score, COUNT(*) as sessions
      FROM session_evaluations
      WHERE score IS NOT NULL
      GROUP BY project_name
      HAVING sessions >= 3
      ORDER BY avg_score DESC
    `).all();

    // Average score by prompt style (min 5 sessions)
    patterns.byPromptStyle = this.db.prepare(`
      SELECT prompt_style, AVG(score) as avg_score, COUNT(*) as sessions
      FROM session_evaluations
      WHERE score IS NOT NULL AND prompt_style IS NOT NULL
      GROUP BY prompt_style
      HAVING sessions >= 5
      ORDER BY avg_score DESC
    `).all();

    // Optimal duration range (sessions scoring 4+)
    patterns.optimalDuration = this.db.prepare(`
      SELECT project_name, AVG(duration_minutes) as avg_duration, COUNT(*) as sessions
      FROM session_evaluations
      WHERE score >= 4 AND duration_minutes IS NOT NULL
      GROUP BY project_name
      HAVING sessions >= 3
    `).all();

    // Time-of-day analysis (4-hour blocks)
    patterns.byTimeOfDay = this.db.prepare(`
      SELECT
        CAST(strftime('%H', started_at) AS INTEGER) / 4 as time_block,
        AVG(score) as avg_score,
        COUNT(*) as sessions
      FROM session_evaluations
      WHERE score IS NOT NULL AND started_at IS NOT NULL
      GROUP BY time_block
      HAVING sessions >= 3
      ORDER BY time_block
    `).all();

    // Overall stats
    patterns.totalEvaluations = totalEvals;
    patterns.overallAvgScore = this.db.prepare(
      'SELECT AVG(score) as avg FROM session_evaluations WHERE score IS NOT NULL'
    ).get()?.avg || 0;

    this._cachedPatterns = patterns;
    this._evalCountAtLastAnalysis = totalEvals;

    return patterns;
  }

  /**
   * Format patterns for AI context. Uses cached results when available.
   * Returns an "Insufficient data" message when below threshold.
   *
   * @returns {string}
   */
  formatForContext() {
    this._ensureDb();

    const minEvals = this.config.learning?.minEvaluations || 50;
    const totalEvals = this._getEvalCount();

    if (totalEvals < minEvals) {
      return `Session Learnings: Insufficient data (${totalEvals}/${minEvals} evaluations)`;
    }

    // Use cached patterns or analyze fresh
    const patterns = this._cachedPatterns || this.analyzePatterns();
    if (!patterns) return `Session Learnings: Insufficient data (${totalEvals}/${minEvals} evaluations)`;

    const lines = [`Session Learnings (from ${patterns.totalEvaluations} evaluations, avg ${patterns.overallAvgScore.toFixed(1)}/5):`];

    // Top/bottom projects
    if (patterns.byProject.length > 0) {
      const top = patterns.byProject.slice(0, 3);
      for (const p of top) {
        lines.push(`- ${p.project_name}: avg ${p.avg_score.toFixed(1)}/5 (${p.sessions} sessions)`);
      }
      const bottom = patterns.byProject.filter(p => p.avg_score < 3.0);
      for (const p of bottom.slice(0, 2)) {
        lines.push(`- ${p.project_name}: avg ${p.avg_score.toFixed(1)}/5 WARNING (${p.sessions} sessions)`);
      }
    }

    // Best prompt styles
    if (patterns.byPromptStyle.length > 0) {
      const best = patterns.byPromptStyle[0];
      const worst = patterns.byPromptStyle[patterns.byPromptStyle.length - 1];
      lines.push(`- Best prompt style: "${best.prompt_style}" (avg ${best.avg_score.toFixed(1)}/5)`);
      if (worst.prompt_style !== best.prompt_style) {
        lines.push(`- Worst prompt style: "${worst.prompt_style}" (avg ${worst.avg_score.toFixed(1)}/5)`);
      }
    }

    // Optimal durations
    if (patterns.optimalDuration.length > 0) {
      const durations = patterns.optimalDuration.map(d => `${d.project_name}: ~${Math.round(d.avg_duration)}min`);
      lines.push(`- Optimal durations (score 4+): ${durations.join(', ')}`);
    }

    // Time of day
    if (patterns.byTimeOfDay.length >= 2) {
      const timeLabels = ['0-4AM', '4-8AM', '8AM-12PM', '12-4PM', '4-8PM', '8PM-12AM'];
      const best = patterns.byTimeOfDay.reduce((a, b) => a.avg_score > b.avg_score ? a : b);
      lines.push(`- Best time block: ${timeLabels[best.time_block] || 'block ' + best.time_block} (avg ${best.avg_score.toFixed(1)}/5)`);
    }

    return lines.join('\n');
  }

  /**
   * Close the SQLite database connection.
   */
  close() {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
}

module.exports = SessionLearner;
```

Do NOT:
- Use LLM calls for pattern analysis (pure SQL queries)
- Run analysis on every evaluation (use threshold-based caching)
- Store full prompts (200 char snippet only -- saves space)
- Add any npm dependencies
  </action>
  <verify>
Run `node -e "const SL = require('./lib/session-learner'); console.log(typeof SL)"` -- should print 'function'.

Run `node -e "const SL = require('./lib/session-learner'); const sl = new SL({ config: {} }); console.log(typeof sl.recordEvaluation, typeof sl.analyzePatterns, typeof sl.formatForContext, typeof sl.close)"` -- should print four 'function' strings.
  </verify>
  <done>
SessionLearner class with SQLite evaluation storage, keyword-based prompt style classification, threshold-gated pattern analysis (SQL queries), and cached formatForContext output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SessionLearner into evaluator, context, and index.js</name>
  <files>lib/session-evaluator.js, lib/context-assembler.js, index.js, config.json</files>
  <action>
**session-evaluator.js changes:**

1. Add `sessionLearner` to the constructor:
After `this.config = config;`, add:
```javascript
this.sessionLearner = deps.sessionLearner || null;
```

Also add `sessionLearner` to the destructured deps parameter and the JSDoc.

2. After persisting to state (after `this.state.logEvaluation(this.state.load(), evaluation);` near the end of evaluate()), add dual-write to SQLite:

```javascript
    // Dual-write to SQLite for pattern analysis (PA-04)
    if (this.sessionLearner) {
      try {
        this.sessionLearner.recordEvaluation({ ...evaluation, prompt });
      } catch (e) {
        // Non-fatal -- state.json is the primary store
        console.log(`[SessionEvaluator] SQLite write warning: ${e.message}`);
      }
    }
```

Note: Pass `prompt` explicitly since it's available in the evaluate() scope but not in the evaluation record.

**context-assembler.js changes:**

1. Add `sessionLearner` to the constructor. After `this.conversationStore = conversationStore;` (added in 07-02), add:
```javascript
this.sessionLearner = sessionLearner;
```

Also add `sessionLearner` to the destructured constructor parameter.

2. Add `_buildLearningsSection()` method after `_buildConversationSection()`:

```javascript
/**
 * Build session learnings section for AI context.
 * Shows pattern insights when enough evaluation data exists.
 * Returns null if sessionLearner is not available.
 * @returns {string|null}
 */
_buildLearningsSection() {
  if (!this.sessionLearner) return null;
  try {
    return this.sessionLearner.formatForContext();
  } catch {
    return null;
  }
}
```

3. Wire into assemble(). After the conversation section (after `if (conversationSection) sections.push(conversationSection);`), add:

```javascript
// 2.97. Session learnings
const learningsSection = this._buildLearningsSection();
if (learningsSection) sections.push(learningsSection);
```

**index.js changes:**

1. Import SessionLearner after the existing imports:
```javascript
const SessionLearner = require('./lib/session-learner');
```

2. Instantiate after reminderManager:
```javascript
// -- Session Learner (v4.0 Phase 07) -----------------------------------------
const sessionLearner = new SessionLearner({ config: CONFIG });
```

3. Pass sessionLearner to SessionEvaluator. Update the `new SessionEvaluator({...})` call:
```javascript
const sessionEvaluator = new SessionEvaluator({
  gitTracker,
  state,
  config: CONFIG,
  sessionLearner,
});
```

4. Pass sessionLearner to ContextAssembler. Add it to the `new ContextAssembler({...})` call:
```javascript
const contextAssembler = new ContextAssembler({
  scanner,
  sessionManager,
  processMonitor,
  state,
  config: CONFIG,
  resourceMonitor,
  healthMonitor,
  revenueTracker,
  trustTracker,
  conversationStore,
  sessionLearner,
});
```

5. Add close() to graceful shutdown, before `process.exit(0)`:
```javascript
sessionLearner.close();
```

**config.json changes:**

Add a `learning` section after the `reminders` section:
```json
"learning": {
  "enabled": true,
  "minEvaluations": 50,
  "analysisInterval": 10
}
```

Do NOT:
- Remove the existing state.logEvaluation call (dual-write, SQLite is supplementary)
- Make sessionLearner a required dependency in any module (all optional)
- Call analyzePatterns on every think cycle (formatForContext handles caching)
  </action>
  <verify>
Run `node -e "const src = require('fs').readFileSync('./lib/session-evaluator.js','utf-8'); console.log(src.includes('sessionLearner'), src.includes('recordEvaluation'))"` -- should print two 'true' values.

Run `node -e "const src = require('fs').readFileSync('./index.js','utf-8'); console.log(src.includes('SessionLearner'), src.includes('sessionLearner'))"` -- should print two 'true' values.

Run `node -e "const c = JSON.parse(require('fs').readFileSync('./config.json','utf-8')); console.log(c.learning.enabled, c.learning.minEvaluations)"` -- should print "true 50".
  </verify>
  <done>
SessionLearner wired into evaluation pipeline (dual-write), AI context (learnings section), and index.js lifecycle (instantiation + shutdown). Config.json has learning section.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test/reminder-manager.test.js</name>
  <files>test/reminder-manager.test.js</files>
  <action>
Use `node:test` and `node:assert` following the established test patterns (see revenue-tracker.test.js and trust-tracker.test.js).

```javascript
'use strict';

const { describe, it, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert/strict');
const Database = require('better-sqlite3');
const path = require('path');
const os = require('os');
const fs = require('fs');

function createTestManager() {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'rm-test-'));
  const dbPath = path.join(tmpDir, 'test.db');
  const notifications = [];
  const mockNotificationManager = {
    notify: (text, tier) => { notifications.push({ text, tier }); },
  };

  const RM = require('../lib/reminder-manager');
  const manager = new RM({
    config: { reminders: { enabled: true, timezone: 'America/New_York' } },
    notificationManager: mockNotificationManager,
  });

  // Override DB path for test isolation
  manager._ensureDb = function() {
    if (this.db) return;
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        text TEXT NOT NULL,
        fire_at TEXT NOT NULL,
        created_at TEXT NOT NULL,
        fired INTEGER DEFAULT 0,
        source_message TEXT
      )
    `);
    this.db.exec(`CREATE INDEX IF NOT EXISTS idx_reminders_pending ON reminders(fired, fire_at)`);
  };

  return { manager, tmpDir, notifications, cleanup: () => { manager.close(); fs.rmSync(tmpDir, { recursive: true, force: true }); } };
}

describe('ReminderManager', () => {
  describe('schema', () => {
    it('creates reminders table on first access', () => {
      const { manager, cleanup } = createTestManager();
      try {
        manager._ensureDb();
        const tables = manager.db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='reminders'").all();
        assert.equal(tables.length, 1);
      } finally { cleanup(); }
    });
  });

  describe('setReminder', () => {
    it('inserts a pending reminder and returns its id', () => {
      const { manager, cleanup } = createTestManager();
      try {
        const id = manager.setReminder('Check YouTube OAuth', '2026-02-18T10:00:00.000Z');
        assert.ok(id > 0);
        const row = manager.db.prepare('SELECT * FROM reminders WHERE id = ?').get(id);
        assert.equal(row.text, 'Check YouTube OAuth');
        assert.equal(row.fired, 0);
      } finally { cleanup(); }
    });

    it('stores source_message when provided', () => {
      const { manager, cleanup } = createTestManager();
      try {
        const id = manager.setReminder('Check OAuth', '2026-02-18T10:00:00.000Z', 'remind me to check OAuth');
        const row = manager.db.prepare('SELECT * FROM reminders WHERE id = ?').get(id);
        assert.equal(row.source_message, 'remind me to check OAuth');
      } finally { cleanup(); }
    });
  });

  describe('checkAndFire', () => {
    it('fires reminders whose fire_at is in the past', () => {
      const { manager, notifications, cleanup } = createTestManager();
      try {
        const pastTime = new Date(Date.now() - 60000).toISOString();
        manager.setReminder('Past reminder', pastTime);
        const count = manager.checkAndFire();
        assert.equal(count, 1);
        assert.equal(notifications.length, 1);
        assert.ok(notifications[0].text.includes('Past reminder'));
        assert.equal(notifications[0].tier, 1); // URGENT
      } finally { cleanup(); }
    });

    it('does not fire reminders whose fire_at is in the future', () => {
      const { manager, notifications, cleanup } = createTestManager();
      try {
        const futureTime = new Date(Date.now() + 3600000).toISOString();
        manager.setReminder('Future reminder', futureTime);
        const count = manager.checkAndFire();
        assert.equal(count, 0);
        assert.equal(notifications.length, 0);
      } finally { cleanup(); }
    });

    it('marks fired reminders as fired=1', () => {
      const { manager, cleanup } = createTestManager();
      try {
        const pastTime = new Date(Date.now() - 60000).toISOString();
        const id = manager.setReminder('Fired reminder', pastTime);
        manager.checkAndFire();
        const row = manager.db.prepare('SELECT fired FROM reminders WHERE id = ?').get(id);
        assert.equal(row.fired, 1);
      } finally { cleanup(); }
    });

    it('does not fire already-fired reminders', () => {
      const { manager, notifications, cleanup } = createTestManager();
      try {
        const pastTime = new Date(Date.now() - 60000).toISOString();
        manager.setReminder('One-time', pastTime);
        manager.checkAndFire();
        const count = manager.checkAndFire();
        assert.equal(count, 0);
        assert.equal(notifications.length, 1); // Only fired once
      } finally { cleanup(); }
    });

    it('returns 0 when no reminders exist', () => {
      const { manager, cleanup } = createTestManager();
      try {
        const count = manager.checkAndFire();
        assert.equal(count, 0);
      } finally { cleanup(); }
    });
  });

  describe('listPending', () => {
    it('returns empty array when no reminders exist', () => {
      const { manager, cleanup } = createTestManager();
      try {
        const pending = manager.listPending();
        assert.deepEqual(pending, []);
      } finally { cleanup(); }
    });

    it('returns only unfired reminders sorted by fire_at', () => {
      const { manager, cleanup } = createTestManager();
      try {
        manager.setReminder('Second', '2026-02-20T10:00:00.000Z');
        manager.setReminder('First', '2026-02-19T10:00:00.000Z');
        // Fire a past one
        const pastTime = new Date(Date.now() - 60000).toISOString();
        manager.setReminder('Fired', pastTime);
        manager.checkAndFire();

        const pending = manager.listPending();
        assert.equal(pending.length, 2);
        assert.equal(pending[0].text, 'First');
        assert.equal(pending[1].text, 'Second');
      } finally { cleanup(); }
    });
  });

  describe('cancelByText', () => {
    it('cancels matching reminders', () => {
      const { manager, cleanup } = createTestManager();
      try {
        manager.setReminder('Check YouTube OAuth', '2026-02-20T10:00:00.000Z');
        manager.setReminder('Check Gumroad sales', '2026-02-20T11:00:00.000Z');
        const count = manager.cancelByText('YouTube');
        assert.equal(count, 1);
        const pending = manager.listPending();
        assert.equal(pending.length, 1);
        assert.equal(pending[0].text, 'Check Gumroad sales');
      } finally { cleanup(); }
    });

    it('returns 0 when no reminders match', () => {
      const { manager, cleanup } = createTestManager();
      try {
        manager.setReminder('Check YouTube', '2026-02-20T10:00:00.000Z');
        const count = manager.cancelByText('nonexistent');
        assert.equal(count, 0);
      } finally { cleanup(); }
    });
  });

  describe('close', () => {
    it('closes the database connection', () => {
      const { manager, cleanup } = createTestManager();
      try {
        manager._ensureDb();
        assert.ok(manager.db !== null);
        manager.close();
        assert.equal(manager.db, null);
      } finally { cleanup(); }
    });

    it('is safe to call multiple times', () => {
      const { manager, cleanup } = createTestManager();
      try {
        manager._ensureDb();
        manager.close();
        manager.close(); // Should not throw
      } finally { cleanup(); }
    });
  });
});
```

Do NOT:
- Make real HTTP requests or LLM calls
- Use any test framework beyond node:test and node:assert
- Skip cleanup of temp directories
  </action>
  <verify>
`node --test test/reminder-manager.test.js` passes all tests.
  </verify>
  <done>
ReminderManager has tests covering schema creation, setReminder, checkAndFire with past/future times, listPending ordering, cancelByText fuzzy matching, and close behavior.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create test/conversation-store.test.js</name>
  <files>test/conversation-store.test.js</files>
  <action>
Replace the existing conversation-store.test.js (if it exists) or create new. Tests the SQLite-backed ConversationStore.

```javascript
'use strict';

const { describe, it, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert/strict');
const Database = require('better-sqlite3');
const path = require('path');
const os = require('os');
const fs = require('fs');

function createTestStore(options = {}) {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cs-test-'));
  const dbPath = path.join(tmpDir, 'test.db');

  const CS = require('../lib/conversation-store');
  const store = new CS({
    dbPath,
    maxMessages: options.maxMessages || 100,
    ttlMs: options.ttlMs || 7 * 24 * 60 * 60 * 1000,
  });

  return { store, tmpDir, dbPath, cleanup: () => { store.close(); fs.rmSync(tmpDir, { recursive: true, force: true }); } };
}

describe('ConversationStore (SQLite)', () => {
  describe('schema', () => {
    it('creates conversations table on first access', () => {
      const { store, cleanup } = createTestStore();
      try {
        store._ensureDb();
        const tables = store.db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='conversations'").all();
        assert.equal(tables.length, 1);
      } finally { cleanup(); }
    });

    it('creates index on ts column', () => {
      const { store, cleanup } = createTestStore();
      try {
        store._ensureDb();
        const indexes = store.db.prepare("SELECT name FROM sqlite_master WHERE type='index' AND name='idx_conversations_ts'").all();
        assert.equal(indexes.length, 1);
      } finally { cleanup(); }
    });
  });

  describe('push', () => {
    it('inserts an entry with role, text, and ts', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'Hello', ts: 1000000 });
        const entries = store.getAll();
        assert.equal(entries.length, 1);
        assert.equal(entries[0].role, 'user');
        assert.equal(entries[0].text, 'Hello');
        assert.equal(entries[0].ts, 1000000);
      } finally { cleanup(); }
    });

    it('defaults ts to Date.now() when not provided', () => {
      const { store, cleanup } = createTestStore();
      try {
        const before = Date.now();
        store.push({ role: 'user', text: 'Hi' });
        const entries = store.getAll();
        assert.ok(entries[0].ts >= before);
      } finally { cleanup(); }
    });

    it('filters credentials before storing', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'My key is ghp_1234567890abcdefghij' });
        const entries = store.getAll();
        assert.ok(entries[0].text.includes('[REDACTED]'));
        assert.ok(!entries[0].text.includes('ghp_'));
      } finally { cleanup(); }
    });
  });

  describe('getRecent', () => {
    it('returns last N entries in chronological order', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'First', ts: 1000 });
        store.push({ role: 'assistant', text: 'Second', ts: 2000 });
        store.push({ role: 'user', text: 'Third', ts: 3000 });
        const recent = store.getRecent(2);
        assert.equal(recent.length, 2);
        assert.equal(recent[0].text, 'Second'); // Chronological order
        assert.equal(recent[1].text, 'Third');
      } finally { cleanup(); }
    });

    it('defaults to 4 entries', () => {
      const { store, cleanup } = createTestStore();
      try {
        for (let i = 0; i < 10; i++) {
          store.push({ role: 'user', text: `Msg ${i}`, ts: Date.now() + i });
        }
        const recent = store.getRecent();
        assert.equal(recent.length, 4);
      } finally { cleanup(); }
    });
  });

  describe('getAll', () => {
    it('returns all entries in chronological order', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'A', ts: 100 });
        store.push({ role: 'assistant', text: 'B', ts: 200 });
        const all = store.getAll();
        assert.equal(all.length, 2);
        assert.equal(all[0].text, 'A');
        assert.equal(all[1].text, 'B');
      } finally { cleanup(); }
    });
  });

  describe('search', () => {
    it('returns entries matching a keyword', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'Check YouTube OAuth', ts: Date.now() });
        store.push({ role: 'user', text: 'Check Gumroad sales', ts: Date.now() + 1 });
        store.push({ role: 'user', text: 'YouTube is great', ts: Date.now() + 2 });
        const results = store.search('YouTube');
        assert.equal(results.length, 2);
      } finally { cleanup(); }
    });

    it('is case-insensitive', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'YouTube video', ts: Date.now() });
        const results = store.search('youtube');
        assert.equal(results.length, 1);
      } finally { cleanup(); }
    });

    it('returns empty array for no matches', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'Hello world', ts: Date.now() });
        const results = store.search('nonexistent');
        assert.equal(results.length, 0);
      } finally { cleanup(); }
    });

    it('returns empty array for empty query', () => {
      const { store, cleanup } = createTestStore();
      try {
        const results = store.search('');
        assert.equal(results.length, 0);
      } finally { cleanup(); }
    });
  });

  describe('clear', () => {
    it('removes all entries', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'A', ts: Date.now() });
        store.push({ role: 'user', text: 'B', ts: Date.now() + 1 });
        store.clear();
        const all = store.getAll();
        assert.equal(all.length, 0);
      } finally { cleanup(); }
    });
  });

  describe('TTL pruning', () => {
    it('removes entries older than TTL', () => {
      const { store, cleanup } = createTestStore({ ttlMs: 1000 }); // 1 second TTL
      try {
        // Insert an old entry
        store.push({ role: 'user', text: 'Old', ts: Date.now() - 2000 });
        store.push({ role: 'user', text: 'New', ts: Date.now() });
        const all = store.getAll();
        assert.equal(all.length, 1);
        assert.equal(all[0].text, 'New');
      } finally { cleanup(); }
    });
  });

  describe('maxMessages cap', () => {
    it('keeps only the newest N messages when cap exceeded', () => {
      const { store, cleanup } = createTestStore({ maxMessages: 3 });
      try {
        for (let i = 1; i <= 5; i++) {
          store.push({ role: 'user', text: `Msg ${i}`, ts: Date.now() + i });
        }
        const all = store.getAll();
        assert.equal(all.length, 3);
        assert.equal(all[0].text, 'Msg 3');
        assert.equal(all[2].text, 'Msg 5');
      } finally { cleanup(); }
    });
  });

  describe('credential filtering', () => {
    it('redacts OpenAI keys', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'key is sk-1234567890abcdefghij1234567890ab', ts: Date.now() });
        const entries = store.getAll();
        assert.ok(entries[0].text.includes('[REDACTED]'));
      } finally { cleanup(); }
    });

    it('redacts Stripe keys', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'stripe key sk_live_abc123def456', ts: Date.now() });
        const entries = store.getAll();
        assert.ok(entries[0].text.includes('[REDACTED]'));
      } finally { cleanup(); }
    });

    it('redacts GitHub PATs', () => {
      const { store, cleanup } = createTestStore();
      try {
        store.push({ role: 'user', text: 'token ghp_abc123def456ghi789', ts: Date.now() });
        const entries = store.getAll();
        assert.ok(entries[0].text.includes('[REDACTED]'));
      } finally { cleanup(); }
    });
  });

  describe('close', () => {
    it('closes the database connection', () => {
      const { store, cleanup } = createTestStore();
      try {
        store._ensureDb();
        assert.ok(store.db !== null);
        store.close();
        assert.equal(store.db, null);
      } finally { cleanup(); }
    });

    it('is safe to call multiple times', () => {
      const { store, cleanup } = createTestStore();
      try {
        store._ensureDb();
        store.close();
        store.close();
      } finally { cleanup(); }
    });
  });
});
```

Do NOT:
- Test the JSON migration (requires file system setup, covered by manual testing)
- Make real LLM calls
- Use any test framework beyond node:test and node:assert
  </action>
  <verify>
`node --test test/conversation-store.test.js` passes all tests.
  </verify>
  <done>
ConversationStore has comprehensive tests covering SQLite schema, push with credentials, getRecent ordering, search case-insensitivity, TTL pruning, maxMessages cap, and close behavior.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create test/session-learner.test.js and update helpers.js</name>
  <files>test/session-learner.test.js, test/helpers.js</files>
  <action>
**test/session-learner.test.js:**

```javascript
'use strict';

const { describe, it, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert/strict');
const Database = require('better-sqlite3');
const path = require('path');
const os = require('os');
const fs = require('fs');

function createTestLearner(configOverrides = {}) {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'sl-test-'));
  const dbPath = path.join(tmpDir, 'test.db');
  const config = { learning: { minEvaluations: 50, analysisInterval: 10, ...configOverrides } };

  const SL = require('../lib/session-learner');
  const learner = new SL({ config });

  // Override DB path for test isolation
  learner._ensureDb = function() {
    if (this.db) return;
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS session_evaluations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,
        project_name TEXT NOT NULL,
        started_at TEXT NOT NULL,
        stopped_at TEXT,
        duration_minutes INTEGER,
        commit_count INTEGER,
        insertions INTEGER,
        deletions INTEGER,
        files_changed INTEGER,
        score INTEGER,
        recommendation TEXT,
        prompt_snippet TEXT,
        prompt_style TEXT,
        evaluated_at TEXT NOT NULL
      )
    `);
    this.db.exec(`CREATE INDEX IF NOT EXISTS idx_evals_project ON session_evaluations(project_name)`);
    this.db.exec(`CREATE INDEX IF NOT EXISTS idx_evals_score ON session_evaluations(score)`);
  };

  return { learner, tmpDir, dbPath, cleanup: () => { learner.close(); fs.rmSync(tmpDir, { recursive: true, force: true }); } };
}

function makeEval(overrides = {}) {
  return {
    sessionId: 'orch-test',
    projectName: 'revenue/web-scraping-biz',
    startedAt: '2026-02-17T10:00:00.000Z',
    stoppedAt: '2026-02-17T10:30:00.000Z',
    durationMinutes: 30,
    gitProgress: {
      commitCount: 3,
      insertions: 100,
      deletions: 20,
      filesChanged: 5,
    },
    score: 4,
    recommendation: 'continue',
    prompt: 'Resume work on this project.',
    evaluatedAt: '2026-02-17T10:31:00.000Z',
    ...overrides,
  };
}

describe('SessionLearner', () => {
  describe('schema', () => {
    it('creates session_evaluations table on first access', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        learner._ensureDb();
        const tables = learner.db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='session_evaluations'").all();
        assert.equal(tables.length, 1);
      } finally { cleanup(); }
    });
  });

  describe('recordEvaluation', () => {
    it('inserts an evaluation record', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        learner.recordEvaluation(makeEval());
        const count = learner.db.prepare('SELECT COUNT(*) as cnt FROM session_evaluations').get().cnt;
        assert.equal(count, 1);
      } finally { cleanup(); }
    });

    it('classifies prompt style from keywords', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        learner.recordEvaluation(makeEval({ prompt: 'Fix the authentication bug' }));
        learner.recordEvaluation(makeEval({ prompt: 'Implement new feature' }));
        learner.recordEvaluation(makeEval({ prompt: 'Explore the codebase' }));
        learner.recordEvaluation(makeEval({ prompt: 'Resume work on this project' }));
        learner.recordEvaluation(makeEval({ prompt: 'Do something else' }));

        const rows = learner.db.prepare('SELECT prompt_style FROM session_evaluations ORDER BY id').all();
        assert.equal(rows[0].prompt_style, 'fix');
        assert.equal(rows[1].prompt_style, 'implement');
        assert.equal(rows[2].prompt_style, 'explore');
        assert.equal(rows[3].prompt_style, 'resume');
        assert.equal(rows[4].prompt_style, 'custom');
      } finally { cleanup(); }
    });

    it('truncates prompt_snippet to 200 chars', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        const longPrompt = 'x'.repeat(500);
        learner.recordEvaluation(makeEval({ prompt: longPrompt }));
        const row = learner.db.prepare('SELECT prompt_snippet FROM session_evaluations').get();
        assert.equal(row.prompt_snippet.length, 200);
      } finally { cleanup(); }
    });
  });

  describe('analyzePatterns', () => {
    it('returns null when below threshold', () => {
      const { learner, cleanup } = createTestLearner({ minEvaluations: 50 });
      try {
        for (let i = 0; i < 10; i++) {
          learner.recordEvaluation(makeEval({ score: 4 }));
        }
        const patterns = learner.analyzePatterns();
        assert.equal(patterns, null);
      } finally { cleanup(); }
    });

    it('returns patterns when at or above threshold', () => {
      const { learner, cleanup } = createTestLearner({ minEvaluations: 5 });
      try {
        for (let i = 0; i < 5; i++) {
          learner.recordEvaluation(makeEval({
            score: 3 + (i % 3),
            projectName: i < 3 ? 'project-a' : 'project-b',
            prompt: i < 3 ? 'Fix the bug' : 'Resume work',
          }));
        }
        const patterns = learner.analyzePatterns();
        assert.ok(patterns !== null);
        assert.equal(patterns.totalEvaluations, 5);
        assert.ok(patterns.overallAvgScore > 0);
      } finally { cleanup(); }
    });

    it('includes per-project average scores', () => {
      const { learner, cleanup } = createTestLearner({ minEvaluations: 3 });
      try {
        for (let i = 0; i < 3; i++) {
          learner.recordEvaluation(makeEval({ projectName: 'test-project', score: 4 }));
        }
        const patterns = learner.analyzePatterns();
        assert.ok(patterns.byProject.length > 0);
        assert.equal(patterns.byProject[0].project_name, 'test-project');
        assert.equal(patterns.byProject[0].avg_score, 4);
      } finally { cleanup(); }
    });
  });

  describe('formatForContext', () => {
    it('shows insufficient data message below threshold', () => {
      const { learner, cleanup } = createTestLearner({ minEvaluations: 50 });
      try {
        learner.recordEvaluation(makeEval());
        const result = learner.formatForContext();
        assert.ok(result.includes('Insufficient data'));
        assert.ok(result.includes('1/50'));
      } finally { cleanup(); }
    });

    it('shows pattern insights above threshold', () => {
      const { learner, cleanup } = createTestLearner({ minEvaluations: 3 });
      try {
        for (let i = 0; i < 5; i++) {
          learner.recordEvaluation(makeEval({ projectName: 'test-project', score: 4, prompt: 'Fix the bug' }));
        }
        const result = learner.formatForContext();
        assert.ok(result.includes('Session Learnings'));
        assert.ok(result.includes('5 evaluations'));
        assert.ok(result.includes('test-project'));
      } finally { cleanup(); }
    });
  });

  describe('_classifyPromptStyle', () => {
    it('classifies fix prompts', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        assert.equal(learner._classifyPromptStyle('Fix the login bug'), 'fix');
        assert.equal(learner._classifyPromptStyle('There is an error in auth'), 'fix');
      } finally { cleanup(); }
    });

    it('classifies implement prompts', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        assert.equal(learner._classifyPromptStyle('Implement user dashboard'), 'implement');
        assert.equal(learner._classifyPromptStyle('Add a new endpoint'), 'implement');
        assert.equal(learner._classifyPromptStyle('Create the test suite'), 'implement');
      } finally { cleanup(); }
    });

    it('classifies explore prompts', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        assert.equal(learner._classifyPromptStyle('Explore the codebase'), 'explore');
        assert.equal(learner._classifyPromptStyle('Read the README'), 'explore');
      } finally { cleanup(); }
    });

    it('classifies resume prompts', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        assert.equal(learner._classifyPromptStyle('Resume work on this project'), 'resume');
        assert.equal(learner._classifyPromptStyle('Continue from where we left off'), 'resume');
      } finally { cleanup(); }
    });

    it('defaults to custom for unrecognized prompts', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        assert.equal(learner._classifyPromptStyle('Do something specific'), 'custom');
      } finally { cleanup(); }
    });
  });

  describe('close', () => {
    it('closes the database connection', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        learner._ensureDb();
        assert.ok(learner.db !== null);
        learner.close();
        assert.equal(learner.db, null);
      } finally { cleanup(); }
    });

    it('is safe to call multiple times', () => {
      const { learner, cleanup } = createTestLearner();
      try {
        learner._ensureDb();
        learner.close();
        learner.close();
      } finally { cleanup(); }
    });
  });
});
```

**test/helpers.js changes:**

Add mock objects for the new Phase 07 modules to `createMockDeps()`. In the returned object, before the `...overrides` spread, add:

```javascript
reminderManager: {
  setReminder: () => 1,
  checkAndFire: () => 0,
  listPending: () => [],
  cancelByText: () => 0,
  close: () => {},
},
sessionLearner: {
  recordEvaluation: () => {},
  analyzePatterns: () => null,
  formatForContext: () => 'Session Learnings: Insufficient data (0/50 evaluations)',
  close: () => {},
},
conversationStore: {
  push: () => {},
  getRecent: () => [],
  getAll: () => [],
  search: () => [],
  clear: () => {},
  close: () => {},
},
```

Note: The existing `conversationStore` mock is not present in helpers.js, so this adds it. If there's a partial mock already, replace it with the full version above.

Do NOT:
- Make real HTTP requests or LLM calls
- Use any test framework beyond node:test and node:assert
- Skip cleanup of temp directories
  </action>
  <verify>
`node --test test/session-learner.test.js` passes all tests.
`node --test 'test/*.test.js'` passes ALL tests (existing + new).
  </verify>
  <done>
SessionLearner has tests covering schema, recordEvaluation, prompt classification, pattern analysis threshold, formatForContext, and close. Helpers.js updated with mocks for all Phase 07 modules. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
- `node --test 'test/*.test.js'` passes ALL tests (existing + new, should be 14 files total)
- `node -e "require('./lib/session-learner')"` loads without error
- SessionLearner can record evaluations, classify prompt styles, and analyze patterns
- Pattern analysis returns null below threshold and insights above threshold
- Reminder manager tests verify full lifecycle
- Conversation store tests verify SQLite migration and new features
- SessionEvaluator dual-writes to both state.json and SQLite
- Config.json has learning section
- Helpers.js has mocks for all Phase 07 modules
- No new npm dependencies added
</verification>

<success_criteria>
SessionLearner stores evaluation data in SQLite with prompt style classification. After 50+ evaluations, it identifies which prompt styles, session durations, and project approaches yield the best scores, and feeds those patterns into the AI context. All Phase 07 modules (reminder manager, conversation store, session learner) have comprehensive test coverage. All existing tests continue to pass.
</success_criteria>

<output>
After completion, create `.planning/phases/07-personal-assistant/07-04-SUMMARY.md`
</output>
